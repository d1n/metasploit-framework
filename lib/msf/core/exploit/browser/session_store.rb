# -*- coding: binary -*-

module Msf

###
#
# The SessionStore class handles persisting information on a browser client
# across connections. For now, the SessionStore keeps all its data in memory and
# will also write to disk on any update.
#
###
module Exploit::Remote::SessionStore

  # @attr [SessionStoreInstance] session_store holds all memory for a session
  attr_reader :session_store

  # Stub initialize to set up the session_store
  def initialize(args={})
    super(args)
    @session_store = SessionStoreInstance.new
  end

  # Mix the extra Client methods into the Client instance
  def filter_request_uri(cli, req)
    cli.include(SessionStoreClientMethods)
    cli.session ||= @session_store.create_session
    cli.inject_fingerprint
    false # don't filter any of these requests, just hook
  end

  # For mixing into the browser client connections
  module SessionStoreClientMethods
    # @attr [Msf::Exploit::Remote::Browser::Session] session for this client
    attr_accessor :session

    protected

    # Call this method to inject HTML into your response and
    # alter response headers so that the subsequent requests/connections
    # will be identifiable.
    #
    # Many of these ideas were taken from Samy's evercookie:
    # https://github.com/samyk/evercookie
    #
    # The fingerprint HTML that is returned does the following:
    # 1. Stores the tag in the browser's cookie
    # 2. Stores the tag in a Flash cookie
    # 3. Stores the tag in the window.name
    # 4. Stores the tag in HTML5's SessionStorage, LocalStorage, GlobalStorage,
    #    and DatabaseStorage
    # 5. Stores the tag in the user's cache
    # 6. [TODO] Stores the tag in Silverlight Isolated Cookies
    # 7. Stores an e-tag header that is detectable later
    # 8. Stores the tag in IE's userData
    #
    # All storage mechanism must be "replace-or-append", so that
    # multiple modules running separate SessionStores will not be confused.
    #
    # Not all of these will be detectable on the next request,
    # but fingerprinting will expose a Tag global that can be sent
    # up as a parameter when reporting data.
    #
    # @return [String] HTML to add to the response
    def inject_cookie(req)
      headers = ['']
      js = %Q|
        (function() {
          var tag = '#{session.tag}';
          var sstag = '#{session.session_store.tag}';
          var m = sstag + '=' + tag; 
          document.cookie = m;
          // set flash cookie
          var hasFlash = false;
          try { hasFlash = !!(new ActiveXObject('ShockwaveFlash.ShockwaveFlash')); } catch(e){}
          hasFlash = hasFlash \|\| (navigator && navigator.mimeTypes &&
              navigator.mimeTypes["application/x-shockwave-flash"] &&
              navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin);
          if (hasFlash) {
            var embed = document.createObject('embed');
            embed.style.visibility = 'hidden';
            embed.setAttribute('type', 'application/x-shockwave-flash');
            document.body.appendChild(embed);
            embed.setAttribute('source', '<<put resource here >>');
            window.___onFlashReady = function() {
              setTimeout(function(){
                if (window.___writeFlash) window.___writeFlash(sstag, tag);
              }, 1);
            };
          }
          // set window.name
          window.name = window.name.replace(/#{session.session_store.tag}=.*?(&\|$)/, '&');
          window.name += m;
          // set html5 storages
          var storages = ['localStorage', 'sessionStorage', 'globalStorage']
          var idx, storage;
          for (idx = 0; idx < storages.length; idx++) {
            storage = storages[idx];
            if (window[storage]) {
              window[storage][sstag] = tag;
            }
          }
          // set cached image
          var img = new Image();
          img.src = 'get_resource_should_go_here.png?tag='+tag;
          img.setAttribute('style', 'visibility:hidden');
          document.body.appendChild(img);
          // set ie userdata
          var div = document.createElement("div");
          div.innerHTML = "<!--[if lte IE 8]><i></i><![endif]-->";
          var isIe8orLower = (div.getElementsByTagName("i").length == 1)
          if (isIe8orLower) {
            var textarea = document.createElement('textarea');
            textarea.setAttribute('style', "visibility:hidden; behavior:url('#default#userData')");
            textarea.setAttribute('id', sstag);
            textarea.setAttribute('sPersistAttr', tag);
            document.body.appendChild(textarea);
            textarea.save('oDataStore');
          }
        })();
      |
    end

    # Checks all the fingerprint methods available, setting window.TAG global
    # if it finds a Tag of the right format anywhere.
    #
    # @return [String] javascript code that sets window.TAG if it finds a stored/cached tag
    def check_cookie(cli, req)
      %Q|
        (function() {
          var sstag = '#{session.session_store.tag}';
          var regex = /#{session.session_store.id}=([0-9a-f])+$/i;
          // check cookie
          var m;
          if (m = document.cookie.match(regex)) {
            window.TAG = m[1];
          }
          // todo: check flash lso cookie
          var hasFlash = false;
          try { hasFlash = !!(new ActiveXObject('ShockwaveFlash.ShockwaveFlash')); } catch(e){}
          hasFlash = hasFlash \|\| (navigator && navigator.mimeTypes &&
              navigator.mimeTypes["application/x-shockwave-flash"] &&
              navigator.mimeTypes["application/x-shockwave-flash"].enabledPlugin);
          if (!window.TAG && hasFlash) {
            var embed = document.createObject('embed');
            embed.setAttribute('style', 'visibility:hidden');
            embed.setAttribute('type', 'application/x-shockwave-flash');
            // flash onload callback
            window.___onFlashReady = function() {
              setTimeout(function(){
                if (window.___readFlash) window.___readFlash(sstag);
              }, 1);
            };
            document.body.appendChild(embed);
            embed.setAttribute('source', '<<put resource here >>');
          }
          // check window.name
          if (!window.TAG && (m = window.name.match(regex))) {
            window.TAG = m[1];
          }
          // check HTML5 targets
          if (!window.TAG && 'Storage' in window) {
            var storages = ['localStorage', 'sessionStorage', 'globalStorage'];
            var idx, storage;
            for (idx = 0; idx < storages.length; idx++) {
              storage = storages[idx];
              if (!window.TAG && window[storage] && (m = window[storage][sstag])) {
                window.TAG = m;
              }
            }
          }
          // try load of cached image
          if (!window.TAG && 'HTMLCanvasElement' in window) {
            var img = new Image();
            img.src = 'get_resource_should_go_here';
            img.onload = function() {
              // todo: load into <canvas>, convert pixels to TAG
              var canvas = document.createElement('canvas');
              canvas.width = '200px';
              canvas.height = '100px';
              canvas.style.visibility = 'hidden';
              document.body.appendChild(canvas);
              var ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              // decode the image pixels
              var imgd = ctx.getImageData(0, 0, 200, 1);
              // TODO: FINISH DECODER
              var i, pngd = '';
              for (i = 0, i < imgd.data.length; i += 4) {
                if (!pix[i]) { break; }
                pngd += String.fromCharCode(pix[i]);
                if (pix[i+1]) pngd += String.fromCharCode(pix[i+1]);
                if (pix[i+2]) pngd += String.fromCharCode(pix[i+2]);
              }
              if (!window.TAG && pngd.match(regex)) {
                window.TAG = pngd;
              }
            };
            img.setAttribute('style', 'visibility:hidden');
            document.body.appendChild(img);
          }

          // check ie userData
          var div = document.createElement("div");
          div.innerHTML = "<!--[if lte IE 8]><i></i><![endif]-->";
          var isIe8orLower = (div.getElementsByTagName("i").length == 1)
          if (isIe8orLower) {
            var textarea = document.createElement('textarea');
            textarea.setAttribute('style', "visibility:hidden; behavior:url('#default#userData')");
            document.body.appendChild(textarea);
            textarea.load('oDataStore');
            if (!window.TAG) {
              window.TAG = textarea.getAttribute('sPersistAttr');
            }
          }
        })();
      |
    end
  end

  # Holds a collection of Sessions
  class SessionStoreInstance
    def initialize
      @mutex = Mutex.new
      @sessions = {} # a map of Tag (any identifier) -> Session
    end

    # Yields the block in a thread-safe way
    def sync(&block)
      @mutex.synchronize(&block)
    end

    # @return [Session] a Session with #session_store = self
    def create_session
      Msf::Exploit::Remote::Browser::Session.new(self)
    end
  end

  # Used to store data about a specific browser client.
  class Session
    # @attr [Msf::Exploit::Remote::Browser::SessionStore] the SessionStore that this Session belongs to
    attr_reader :session_store

    # @param [SessionStore] session_store the Store that allocated and retains this Session
    def initialize(session_store)
      @session_store = session_store
      @data = {}
    end

    # @param [String] key the key to set
    # @param [#to_hash] value the value to store
    # @param [Hash] opts the options hash
    # @option opts [String] :save saves the Session to disk after this request. defaults to true.
    def set(key, value, opts={})
      set({ key => value }, opts)
    end
    alias_method :[]=, :set

    # @param [Hash<#to_s,#to_json>] data to merge into the hash
    # @param [Hash] opts the options hash
    # @option opts [String] :save saves the Session to disk after this request. defaults to true.
    def set(data, opts={})
      # run all of data's keys through #to_s
      safe_hash = Hash[data.map{ |k,v| [k.to_s, v] }]
      session_store.sync { @data.merge(safe_hash) }
      save unless opts.fetch(:save, true)
    end

    # @param [#to_s] key the key to lookup
    # @return [#to_json] value
    def get(key)
      session_store.sync { @data[key.to_s] }
    end
    alias_method :[], :get

    # Persists the @data to a file (for now).
    def save; end
  end

end # SessionStore

end # Msf
